<template>
  <div>
    <router-link to="/guides/asm/"><h5>&lt;- Вертай в зад, обратно к гайдам</h5></router-link>
    <h1>Ассемблер. Базовые команды процессора. Разбор первой лабораторной.</h1>
    <section>
      <h2>Общие понятия</h2>
      <p>
        О том, что вообще из себя представляет ассемблер, можно почитать в
        <router-link to="/guides/asm/prerequisites">первом гайде</router-link>
        ,
        который описывает настройку пакета SPASM. В этой же статье мы начнём с некоторых
        общих понятий и терминов, а затем и перейдём к разбору первой лабораторной.
        В зависимости от варианта, итоговая программа будет либо отличаться от примера на
        один (1) символ, либо будет состоять практически целиком из приёмов, никоим
        образом не описанных ранее, так что крепитесь.
      </p>
      <p>А, и ещё. В тексте могут встречаться большие и страшные слова, особенно в
        секции описания директив компилятора. То, что здесь что-то написано, ещё не
        означает, что это обязательно читать и тем более понимать и запоминать. Многие
        вещи достаточно просто записать в блокнотик, как шаблон, и потом втыкать в код -
        понимание придёт со временем и опытом.</p>
    </section>
    <section>
      <h2>Лекционный режим</h2>
      <p>На этой странице работает новая, революционная фича, способствующая
        погружению в атмосферу КФ МГТУ: лекционный режим просмотра статьи. Активируется
        нажатием на вот эту <a v-on:click="toggleLectureMode">кнопку</a>. Удачного
        изучения!</p>
    </section>
    <transition name="fade-left" mode="out-in" appear>
      <template v-if="!lectureMode">
        <div key="0">
          <section>
            <h2>Регистры</h2>
            <p>Регистры - это то, с чем непосредственно взаимодействует процессор. У каждого
              регистра есть своё назначение и название. К регистрам общего назначения (РОН) относят
              A (аккумуляторный, арифметический), B (регистр базовой индексации), C (регистр циклов, счётчиков),
              D (регистр данных, ввода-вывода), и некоторые Другие™, перечислять которые я,
              пока, не стану. Эти четыре регистра доступны в ряде ипостасей: RAX (64 бита), EAX (32 бита),
              AX (16 бит), AH (старшие 8 бит AX) и AL (младшие 8 бит AX). Технически, эти регистры почти
              целиком и полностью равноправны, но, как и в нашем обществе, это не значит ровным
              счётом ничего. У каждого регистра есть своё предназначение, по которому он используется
              чаще всего - AX участвует в арифметике, в DX традиционно пихают строки, и так далее.</p>
            <p>Кроме перечисленных регистров, существуют и более узконаправленные регистры, такие как
              SI, применяемый для итерации по массивам и CS, хранящий адрес текущей инструкции машинного кода.</p>
          </section>
          <section>
            <h2>Работа с памятью</h2>
            <p>Изучая код и способы адресации, можно сделать вывод, что Ассемблер позволяет нам работать
            не только с регистрами, но и "напрямую" с оперативной памятью. Звучит заманчиво, но реальность
            сурова - это всё ЛПП, или Ложь, Враньё и Провокация. На самом деле адрес данных при наличии
            сдвига высчитывается в регистре B, а результат сохраняется в неком буферном регистре, с
            которым уже работает процессор. А буфер, очевидно, как Москва - не резиновый. Именно
            поэтому хотя бы одна операнда обязана быть регистром.</p>
            <p>Кроме этого балагана есть ещё регистр флагов, в котором каждый бит отвечает за результат
            некой логической операции, будь то равенство или что-то ещё. Напрямую с ним взаимодействовать
            если и можно, то однозначно не стоит - над этим корячятся различные условные переходы,
            подробнее о которых можно будет почитать чуть ниже в этой же статье.</p>
          </section>
          <section>
            <h2>Разбор директив компилятора</h2>
            <p>Кроме непосредственно инструкций процессора существует и такая каста команд, как
            макросы и директивы компиляции. Эти штукенции обрабатываются не самим процессором во время
            исполнения программы, а компилятором во время трансляции в машинный код. Рассмотрим
            директивы из примера:</p>
            <pre v-highlightjs><code class="x86asm">.MODEL small
.STACK 256
.DATA
array db 1, 2, 3, 4, 7, 5, 6
maxStr db ?, 13, 10, '$'
.CODE
.STARTUP</code></pre>
            <p>Директивы до .CODE влияют не на логику программы, а на "подготовку", осуществляемую
            перед её запуском. Это такие вещи, как определение структуры программы, размера стека
            и предобъявленных массивов данных, которые мы ещё именуем "переменными".</p>
            <p><span class="code">.MODEL small</span> несёт ответственность за структуру всей программы,
            т.е. такую нудятину, как сегментация данных, размер файла и прочий, не очень важный
            для нас мусор. Шибко любопытные могут почитать подробнее <a href="https://lmgtfy.app/?q=%D0%B0%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80+model+">тут</a>,
            остальным же достаточно знать, что в нашем курсе с лихвой будет хватать опции "small",
            которая явно разделяет сегмент машинного кода и сегмент данных, и предназначена
            для сравнительно небольших программ.</p>
            <p><span class="code">.STACK 256</span> отвечает за выделение памяти под стек.
            <i>Памятливые</i> (ха-ха) люди вспомнят, что оперативная память делится на две условных
            секции: стек и куча (heap). Стек объявляется и заполняется заранее, содержит в себе
            программный код, в нём же лежат переменные и подобная им гадость. К стеку мы имеем
            лёгкий и быстрый доступ, в него мы можем легко делать push/pop, там всё спокойно,
            контролируемо и лампово. Противоположностью стека является куча - выжженное поле,
            пост-апокалиптическая свалка, в которую кое-как накидали данные, память в которой
            выделяется и очищается случайным образом в неизвестном заранее порядке, а вокруг
            бегают щенки Цербера. С кучей мы (как минимум, пока) работать не будем,
            потому что если притвориться мёртвым, Цербер кусать не станет. Что же касается стека,
            256/512 байт под него должно хватить, не перебарщивайте.</p>
            <p><span class="code">.DATA</span> - начало описания тех самых предобъявленных данных.
            Всё, описанное тут, будет загружено в стек рядом с машинным кодом.</p>
            <p><span class="code">maxStr db ?, 13, 10, '$'</span> - строка с объявлением
            "переменной". Я выбрал для пояснения эту строку, а не массив, потому что здесь представлены
            сразу несколько способов заполнить массив. По порядку: "maxStr" - имя переменной,
            то есть её адрес в стеке. "maxStr" существует только для нас - компилятор уже будет
            иметь представление о том, какой объём будет у скомпилированного кода, определит,
            куда запишет этот массив и подставит конкретный адрес вместо "maxStr" в код, как
            численную константу. Затем идёт объявление размерности элементов: "db" =
            "define byte", каждый элемент будет занимать ровно один байт. Далее массив
            заполняется данными. ? - пропуск инициализации, то есть место под элемент будет
            выделено, но ничего записано туда не будет - останется мусор, не убранный за прошлой
            программой. Полезно, когда мы достоверно знаем, что будем перезаписывать эту область
            массива, что позволит сэкономить на ресурсах. 13 и 10 - обычные числа, соответствующие
            кодам символов '\r' и '\n' - вместе они отвечают за перенос строки. Возврат каретки
            ('\r') в современных системах уже давно не требуется, '\n' прекрасно работает в гордом
            одиночестве. '$' будет заменён на число, соответствующее коду символа доллара.
            Почему доллар? Потому что так решили, при выводе в консоль DOS принимает за ограничитель
            символ доллара, а не непечатный символ, как '\0' в Си. Да, я тоже не понимаю, почему.</p>
            <p>Если записать в одних кавычках несколько символов, катастрофы не случится - компилятор
            грамотно разложит их на самостоятельные элементы массива. Таким образом, записи
            <span class="code">array db 'Hello'</span> и
            <span class="code">array db 'H', 'e', 'l', 'l', 'o'</span> идентичны (в случае с размерностью
            в один байт, конечно же). Есть и третий способ записать тоже самое - конкретные числа с кодами
            символов, но мне жаль своё и ваше время. Запомнить тут нужно одно - для процессора нет
            никакой разницы между числами и символами. Это всё числа, просто в некоторых контекстах
            эти числа пробиваются по таблице символов и на экране появляются соответствующие им
            картинки. Является ли число символом или нет в данном контексте - проблема самого символа,
            с высоты процессорной колокольни это не играет никакой роли.</p>
            <p><span class="code">.CODE</span> сообщает компилятору, что описание данных закончилось, а
            последующие строки представляют саму логику программы.</p>
            <p><span class="code">.STARTUP</span> - точка входа в нашу программу, аналог
            <span class="code">void main()</span> в Си. Первое время будет липнуть вплотную к .CODE,
            потом придут серьёзные дядьки-процедуры и жестоко разделят эту парочку.</p>
            <p>В конце мы ещё будем наблюдать <span class="code">.EXIT</span>, который
            заменяется на код, осуществляющий выход из программы и передачу управления обратно системе,
            и <span class="code">END</span>, который прозрачно намекнёт компилятору на то, что пора
            бы сворачиваться.</p>
          </section>
          <section>
            <h2>Собственно, программный код</h2>
            <p>Вы могли уже заметить, что программный код на Ассемблере часто делят на блоки по 3-4 строки.
            Это делается потому, что примерно столько команд и уходит на одно элементарное логическое
            действие, на котором строится вся логика программы. В этом, на самом деле, и заключается
            разница между программированием на <strike>нормальном</strike> более высокоуровневом
            языке и Ассемблере: при разработке на условном Си вы, хотите вы того или нет, всегда
            проходите три этапа: формирование человекопонятного алгоритма, его перевод в логический
            алгоритм и затем запись этого алгоритма в виде Си-кода. На Ассемблере между фазами 2 и 3
            появляется новая, бонусная стадия: "ГОСПОДИ, ЧТО ТУТ ВООБЩЕ ПРОИСХОДИТ, ГДЕ ЧТО ЛЕЖИТ,
            ААААААААААААААААААААААААААА". В моём опыте, после выполнения первых двух лабораторных
            работ в голове что-то щёлкает и общие концепции работы с Ассемблером усваиваются. До
            этой точки, работа больше напоминает тщетные попытки выбраться из тёмного леса, где ни
            черта не видно, категорически не хватает места, у вас восемь рук и вы жонглируете
            горящими факелами, потому что надо, а мозг в этом время расплывается окончательно и
            <i>решительно</i> не понимает, что вообще происходит. Это пройдёт - работает принцип
            "Всё просто, потому и сложно". Ассемблер до ужаса прост и примитивен в плане
            набора команд и возможностей, из-за чего сложность перетекает из формирования
            самой бизнес-логики в разбиение, казалось бы, и так атомарных процедур, вроде
            вывода данных, на ещё более простые команды.</p>
            <p>Ну да ладно, мы здесь не ради лирических отступлений. Приступим к разбору:</p>
            <pre v-highlightjs><code class="x86asm">    mov cx, 7
    lea si, array
    mov al, array[0]
cycle:
    cmp al, [si]
    ja next
    mov al, [si]
next:
    inc si
    loop cycle
    add al, 30h
    mov maxStr[0], al
    mov ah, 9h
    lea dx, maxStr
    int 21h</code></pre>
            <p>Так. Ага. Ммммммм.</p>
            <p>Херня какая-то. Дубль два, теперь по блокам и с (нормальными) комментариями.</p>
            <pre v-highlightjs><code class="x86asm">    ; Подготовка к итерации массива
    mov cx, 7  ; Задаём счётчик цикла
    lea si, array  ; Подгружаем массив в память
    mov al, array[0]  ; В al будет лежать максимальный элемент, пока не вычислили - первый

    ; Обработка массива
cycle:
    cmp al, [si]  ; Сравнить хранимый максимум с текущим элементом
    ja next  ; Если максимум больше, пропускаем обновление
    mov al, [si]  ; Иначе записать текущий элемент на место максимума
next:
    inc si  ; Переход к следующему элементу
    loop cycle  ; Реализация цикла со счётчиком в CX

    ; Перевод числа в символ
    add al, 30h  ; 30h, или 48, или '0' - код символа нуля. Прибавив к однозначному числу, получаем его цифру.
    mov maxStr[0], al  ; Записываем в первый символ строки

    ; Вывод результата
    mov ah, 9h  ; Загружаем строку в DX для вывода
    lea dx, maxStr  ; Задаём код операции DOS
    int 21h  ; Вызываем прерывание 21h, передавая управление системе DOS</code></pre>
            <p>Так-то лучше. Перед тем, как объяснять код, обратим наш взор на явно
              выбивающиеся из общего кода <span class="code">cycle:</span> и
              <span class="code">next:</span>. Если поставить слово с двоеточием перед
              инструкцией, мы создаём то, что называют метками, в зарубежной литературе -
              ярлыками (labels, популярен и транслитерированный вариант - лейблы). Метки
              можно передавать в качестве аргумента особым операциям, в частности - командам
              (без)условных переходов ((un)conditional jumps, прыжки) и некоторым другим, как
              <span class="code">loop</span>. Как и переменные, метки существуют только в исходном
              коде - при компиляции уже известен адрес конкретной инструкции, и непонятные букувки
              меняются на более привычные компутеру числовые константы.</p>
            <p>Глазки на первый блок: <span class="code">lea</span>, или
            load effective address - команда, идентичная mov. mov просто загружает значение в
            указанный регистр/область памяти. lea высчитывает адрес переменной/элемента массива/etc. и
            кладёт его в указанный регистр. Остаётся два "почему": почему счётчик грузится именно
            в CX, а максимум - именно в AL? Всё достаточно просто и неинтересно. CX, как было
            описано выше, считается регистром-счётчиком. Когда мы вызываем команду loop, она
            заглядывает в регистр CX, сравнивает его с нулём и уменьшает на единицу. Если он
            был больше нуля, происходит переход к указанной метке (в нашем случае, cycle). Иначе
            происходит целое ничего и программа идёт дальше по командам. Функциональный
            аналог можно записать примерно так:</p>
            <pre v-highlightjs><code class="x86asm">cmp cx, 0  ; Сравнить с нулём
dec cx  ; Уменьшить на единицу
ja cycle  ; Прыгнуть к метке, если содержимое превышало ноль</code></pre>
            <p>
              Фактически, мы имеем цикл for от числа в CX до нуля включительно с шагом в единицу.
              Число итераций цикла равно числу, которое мы изначально загружаем в CX, при условии,
              что мы своими грязными ручонками не меняем этот регистр по ходу цикла.
            </p>
            <p>Что же касается AL, то тут всё ещё проще, никаких интриг. Регистр пустой? Пустой.
            Используется для каких-то операций, которые будут нам нужны в цикле? Нет. Ещё и по природе
            своей арифметический. Туда и положим. Могли ли мы использовать для этой цели, скажем,
            BL? Могли. Но не стали. И так сойдёт.</p>
            <p>А теперь посмотрим на сам цикл. Нотация "[si]" по смыслу идентична разименованию
            указателя, или "*si" в Си. Вместо того, чтобы работать со значением, записанным в SI,
            мы работаем со значением, записанным в память по адресу из SI, т.е. с текущим
            элементом массива. "inc si" идентично "si++", сдвигая указатель на байт дальше по массиву,
            то есть на следующий элемент. Это всё достаточно простые действия, давно с этим
            знакомы. Вот cmp - это интересно, это мощь. Что он вообще делает? Как он сравнивает числа?
            Где лежит результат и как с ним работать? Поясняю.</p>
            <p>Под капотом cmp реализован через вычитание. Из левой операнды вычитается правая,
            и согласно результату в том самом, легендарном регистре флагов развешиваются
            соответствующие пометочки. Доступ к этим флагам реализуется через всяческие условные переходы.
            Их много, большая их часть идентична операторам сравнения из привычной нам математики, которые
            "вставляются" между операндами. Этих прыжков целая табличка, смотреть на которую страшно
            и одна мысль о том, что их придётся запоминать, повергает в шок. Но всё проще -
            имена этих переходов строятся по крайне примитивным законам, которые я сейчас вам и опишу.</p>
            <hr>
            <ul>
              <li>j = jump = прыгнуть (совершить переход). Служит префиксом для всех команд.</li>
              <li>n = not = "не", инверсия условия.</li>
              <li>g = greater = больше (с учётом знака).</li>
              <li>l = less = меньше (с учётом знака).</li>
              <li>a = above = "выше" ("больше" для беззнаковой арифметики).</li>
              <li>b = below = "ниже" ("меньше" для беззнаковой арифметики).</li>
              <li>e = equal = равны.</li>
              <li>z = zero = ноль, в случае с CMP выполняет абсолютно то же самое, что и e, но в
              зависимости от контекста может быть более читаемым (подробнее об этом во второй лабе).</li>
              <li>p = parity = паритет, т.е. чётность числа единиц в младшем байте.</li>
              <li>s = sign = знак, равен единице, если в старшем бите - единица, т.е. число считается
              "отрицательным".</li>
              <li>o = overflow = переполнение разрядной сетки в знаковой арифметике.</li>
              <li>c = carry = переполнение разрядной сетки в беззнаковой арифметике.</li>
            </ul>
            <p>Касательно Carry и Overflow - я тоже слабо понимаю, что там происходит. Суть в чём:
            они оба выполняют идентичную функцию, а именно служат для промышленного отлова косяков
            в разных видах арифметики. Флаг Overflow вывешивается, если сбился знак - например,
            при сложении двух положительных чисел получилось отрицательное:<br>
            0111 1111 + 0000 0001 = 1000 000. Флаг Carry же вывешивается, когда разрядную сетку
            порвало вообще в клочья и нам пришлось отдать/забрать
            единицу у тёмных сил: 1111 1111 + 0000 0001 = 0000 0000. Просрали единицу, бей тревогу,
            вешай Carry.</p>
            <p>Отдельно отмечу, что компьютеру, в отличие от программиста, глубоко насрать на наличие
            знака у числа. Двоичное представление чисел в компьютерах устроено так, что одна и та же
            запись может быть рассмотрена и как отрицательное число, и как положительное, и процессор
            с ними будет работать одинаково - учитывать знак или нет, это проблема программиста.
            Если вам важен знак, вы, фактически, "теряете" в диапазоне, т.к. один бит перестаёт
            (для вас, это важно) быть значащим и просто отвечает за проверку числа на отрицательность.
            Если в вашей математике нужно учесть знак, используйте overflow и greater/less, если нет -
            carry и above/below.</p>
            <hr>
            <p>Лексику условных переходов изучили, приступаем к грамматике: как строятся названия переходов?
            Первым всегда идёт j, что служит опознавательным признаком перехода. Затем может идти
            опциональный n, который изменит проверку на противоположную. Затем идёт флаг из лексического
            набора, описанного выше. Если это флаг сравнения (a, g, b, l), после него может стоять e для
            нестрогого сравнения. Смотрим на примере:</p>
            <ol>
              <li>ja = jump if above = переход при условии, что левая операнда больше правой без учёта знака;</li>
              <li>jae = jump if above or equal = переход при условии, что левая операнда больше или равна правой;</li>
              <li>jnae = jump if not above or equal = переход при условии, что левая операнда не больше и не равна
              правой, т.е. меньше - идентично jb.</li>
            </ol>
            <p>Надеюсь, общая концепция ясна. Есть и несколько выбивающихся из общего ряда приколистов. В частности,
            есть борзый jmp = jump, которому вообще класть на ваши условия (безусловный переход), есть
            jpe = jump if parity even (если число единиц чётное), идентичный jp, но более читаемый,
            jpo = jump if parity odd (если число единиц нечётное), идентичный jnp, и главный тролль
            в этом зоопарке - jxcz, который не встречается почти никогда, проверяет CX на равенство нулю
            и, что иронично, не имеет инвертированной версии.</p>
            <hr>
            <p>Впрочем, вернёмся к насущному вопросу. В нашем случае, команда
            <span class="code">ja</span> просто пропускает обновление хранимого максимума.</p>
            <p>После цикла идут два финальных блока, подобные Атласу, на плечах которых
            зиждется вывод строки в консоль. <span class="code">add al, 30h</span>
            переводит число из, собственно, обычного числа в символ. Бесхитросно, но почему?
            Всё до ужаса просто. Цифры в таблице идут по порядку, первая - ноль, имеет кодовый
            номер 48, или 30h в шестнадцатеричной системе. Прибавив положение символа нуля
            мы получаем символ, соответствующий нашему (однозначному) числу. Легко и просто.</p>
            <p>Пока речь не зайдёт о двузначных числах (sometimes, foreshadowing is obvious).</p>
            <p>Вишенкой на торте становится конструкция, которую однозначно следует запомнить,
            ибо она является фундаментом взаимодействия с юзверем.
            <span class="code">int 21h</span> - вызов прерывания по коду 0x21. Вообще, прерывания
            заключаются в том, что мы временно приостанавливаем нашу программу и передаём
            штурвал лошку с указанным кодом. В нашем случае, под горячую руку попадается
            сама ОС (21h), которая уже заглядывает в регистр ah, палит там код
            конкретного сервиса, и соответственно коду делает разные полезные вещи.
            Конкретно 9h тыкает пальцем в регистр DX и властно говорит "Там строка.
            Выведи." Как любой послушный пёсель, DOS, радостно виляя хвостом, ищет
            в памяти строку по адресу из DX и идёт по ней до символа доллара, выводя
            найденное на экран. Вот и всё, не так уж и страшно, не правда ли?</p>
          </section>
          <section>
            <h2>Разбор конструкций, не рассмотренных в первом варианте</h2>
            <p>А, нет, всё-таки страшно. Первого варианта хватает для решения
            ну первых <i>четырёх</i> вариантов, и то с натяжечкой. Всё, что идёт далее,
            оставлено на самостоятельное изучение.</p>
            <p>Второй вариант предельно прост. Так как теперь у нас на мушке не максимальный,
            а минимальный элемент, так что <span class="code">ja</span> меняет парик
            и превращается в <span class="code">jb</span>. Лафа.</p>
            <p>Третий и четвёртый вариант тоже парные, но в них есть небольшая заковырОчка:
            вместо элемента нам нужен его порядковый номер. Само собой, логика поиска
            максимального/минимального элемента в изменении не нуждается, зато бонусом
            нам нужно хранить в отдельном регистре порядковый номер элемента.
            Кстати об этом, как его вообще получить? Цикл-то идёт не вверх, а вниз.
            Положим хранимый индекс в регистр BL. Почему BL? Потому что он никем не занят.
            Затем, вместе с обновлением максимума мы должны и обновить его номер. Раз цикл
            идёт вниз, в регистре CX в любой данный момент времени лежит число
            оставшихся элементов массива. Если вычесть это число из длины массива,
            мы получим индекс текущего элемента. Если вычесть это число из длины+1,
            мы получим порядковый номер. Таким образом, для массива из семи элементов
            мы имеем:</p>
            <pre v-highlightjs><code class="x86asm">cycle:
    cmp al, [si]
    ja next
    mov al[si]
    ;; Новый код
    mov bl, 8
    sub bl, cl  ; Вычесть из bl содержимое cl
    ; Здесь можно вычитать либо cx из bx, либо cl из бл.
    ; Не могу сказать точно, что лучше, ибо зависит от контекста.
    ; Когда есть 100% гарантия, что счётчик умещается в один байт - можно брать cl,
    ; и это будет безопаснее, а то хрен знает, какой мусор ещё в bh валяется.
    ; Если в bh достоверно мусора нет, сойдёт и bx-cx. Не так важно, на самом деле,
    ; ведь если программа работает - трогать её не стоит.

    ;; Старый код
next:</code></pre>
            <p>Кроме этого, стоит ещё заменить в блоке записи результата в строку
            al на bl, но с этим, думаю, справятся все.</p>
            <p>Во вариантах 5-10 появляется такой диковинный зверёк, как ввод данных
            с клавиатуры. Осуществить эту дичь можно посредством вызова DOS-сервиса
            по коду 08h, после чего единственный введённый с клавиатуры символ исчезнет
            из консоли, а его код окажется записан в... al. Ой, как удобно.</p>
            <pre v-highlightjs><code class="x86asm">; Ввод цифры с клавиатуры
mov ah, 8  ; Код операции "Ввод без эха"
int 21h  ; Теперь в al лежит введённый символ
sub al, 30h  ; Вычитаем 48 для перевода из символа в число</code></pre>
            <p>Во вариантах 5-7 и 10 требуется посчитать количество
            элементов в массиве. Для этого в bl следует положить счётчик, изначально
            равный нулю, а затем при выполнении условия повышать его на единицу командой
            <span class="code">inc bl</span>. Для проверки чисел
            на равенство используется всё тот же cmp и переходы je и jne.
            Для проверки на предмет превышения заданных значений используются всё те же
            ja и jb. В 10 варианте вводится внезапный твист в виде символьного массива
            и ввода символа с клавиатуры. Там достаточно убрать
            <span class="code">sub al, 30h</span> (ибо нам и нужен код символа, а не
            число, соответствующее цифре) и изменить переменную array таким образом,
            чтобы там лежал массив видимых символов, а не непечатного мусора:
            <span class="code">array db '123 text'</span>, например.</p>
            <p>Больнее всего будет беднягам с вариантами 8 и 9, т.к. там требуется сумма
            цифр, а сумма с лёгкостью может превысить однозначные числа. Очевидно,
            что с двузначными +30h не прокатит: десяточка выдаст нам ":", дальше - лучше.</p>
            <p>Начнём с того, что при объявлении строки вывода следует добавить ещё один слот,
            число-то теперь может до двух символов занимать. В зависимости от уровня вашей
            лени можно пойти двумя путями: вывести число в формате 05, если оно меньше 10,
            и более геморный, зато канонiчный путь с проверкой на двузначность.</p>
            <p>Первый вариант предельно прост. Делим число на десять, частное в первый байт,
            остаток во второй, и, собственно, всё. Остаётся один вопрос: а делить-то как?
            Делимое в AX, делитель куда хотим, главное, чтобы в регистр, а затем
            <span class="code">div &lt;делитель></span>. По итогу в al будет лежать
            частное, а в ah - остаток от деления.</p>
            <pre v-highlightjs><code class="x86asm">    mov al, bl  ; Переносим собранную сумму из bl в al для деления
    xor ah, ah  ; Очищаем ah, чтобы код прошлой операции не мешался при делении. XOR чего-либо с самим собой всегда даёт 0, и по загадочной причине это дешевле, чем mov 0.
    mov bl, 10
    div bl  ; Делить на константу нельзя, обязательно на регистр. Взрослым дядькам, видимо, виднее.

    add ax, 3030h  ; Прибавляем по 30h к частному и к остатку.
    mov maxStr[0], al
    mov maxStr[1], ah</code></pre>
            <p>
              Если же вы, как и я, болеете мазохизмом, у нас появляется новая проверка:
              если частное составило 0, мы кладём остаток в первый символ, а во второй
              пишем пробел. Пробел туда можно записать ещё при инициализации программы,
              а можно и ручками в коде. Я предпочитаю первое: <span class="code">maxStr db ?, ' ', 13, 10, '$'</span>.
              Код проверки резонно поставить между переводом в символы и записью в строку:
            </p>
              <pre v-highlightjs><code class="x86asm">    add ax, 3030h
    cmp al, 30h  ; Сравниваем с символом нуля, а не нулём, ибо перевод уже произведён
    je write_single_digit  ; Прыжок, если они равны

    ; Иначе
    mov maxStr[0], al
    mov maxStr[1], ah
    jmp print

write_single_digit:
    maxStr[0], ah

print:
    lea dx, maxStr
    mov ah, 09h
    int 21h</code></pre>
          </section>
          <section>
            <h2>Как-то так :)</h2>
            <p>Мой гайд на этом заканчивается. Если остались какие-то вопросы -
            <router-link to="/contacts/">спросите</router-link>. Моя риторическая
            диарея не всегда понятна людям со стороны, так что я к такому готов.</p>
          </section>
        </div>
      </template>
      <template v-else>
        <div key="1">
          <section>
            <h2>Подведение итогов</h2>
            <p>Ну, собственно, на этом всё. Оглавление у вас есть, материал я вам дам
              перед экзаменом, чтобы была мотивация слушать лекции и читать литературу.</p>
            <img id="lecture" src="../assets/lecture.jpg" alt="Все!">
          </section>
        </div>
      </template>
    </transition>
  </div>
</template>

<script>
export default {
  name: "ASMGuide1",
  data: function () {
    return {lectureMode: false}
  },
  methods: {
    toggleLectureMode() {
      this.lectureMode = !this.lectureMode
    }
  }
}
</script>

<style scoped>
#lecture {
  border-radius: 20px;
  width: 400px;
  display: block;
  margin: 0 auto;
}
</style>