<template>
  <div>
    <router-link to="/guides/asm/"><h5>&lt;- Вертай в зад, обратно к гайдам</h5></router-link>
    <h1>Ассемблер. Буферизованный ввод. Проверка числа на чётность. Разбор
    второй лабораторной работы.</h1>
    <section>
      <h2>Небольшое предисловие</h2>
      <p>Если вы внимательно читали разбор <router-link to="/guides/asm/lab1">
      первой лабораторной работы</router-link>, в этой статье для вас новой информации
      практически не будет, как, собственно, и в последующих. Первая статья выполняет
      роль порога вхождения в Ассемблер. Её просто нужно переступить, после неё
      каких-то кардинально новых концептов появляться не будет. Главное - понять
      основные принципы работы с Ассемблером. Если же вы ещё не прочитали
      ту статью (или читали невнимательно, или же пропускали куски),
      настоятельно рекомендую это сделать сейчас, в идеале следуя за инструкциями
      в реальном времени, чтобы сразу закрепить изученное.</p>
      <p>Сегодня мы изучим ввод не одного символа, а целой строки из консоли,
      рассмотрим проверку чисел на чётность и повторно разберём перевод
      двузначных чисел в символьный вид, ибо теперь он фигурирует во всех вариантах,
      а я могу с уверенностью сказать, что приличная доля читающих смело игнорирует
      мои рекомендации. Как выразился один мой близкий друг, "Я, конечно, гордый,
      но повторю ещё раз".</p>
      <p>Ну что же, приступим!</p>
    </section>
    <section>
      <h2>Буферизованный ввод данных</h2>
      <p>Буферизованные ввод и вывод данных через консоль реализуются практически
      одинаково. Вспомним, как осуществляется вывод:</p>
      <pre v-highlightjs><code class="x86asm">string db 'Hello, world!', 13, 10, '$'

lea dx, string  ; Загрузка адреса в dx
mov ah, 9  ; Установка кода операции вывода строки
int 21h  ; Вызов сервиса DOS</code></pre>
      <p>Как вы, надеюсь, помните (ибо конструкция действительно фундаментальная),
      <span class="code">mov ah, КОД</span> и <span class="code">int 21h</span>
      вместе осуществляют вызов некоторой системной процедуры, определяемой записанным
      в AH кодом. В случае с 9, по адресу из регистра DX будет выведена строка
      символов вплоть до символа-ограничителя, которым служит знак доллара ('$').
      Операция же <i>ввода</i> строки соответствует коду 0Ah, который запишет
      введённую в консоль строку в массив по адресу, опять-таки лежащему в DX.
      При этом сам массив будет иметь несколько иную структуру:</p>
      <pre v-highlightjs><code class="x86asm">array db 8, ?, 8 dup(?)

lea dx, array
mov ah, 0Ah
int 21h</code></pre>
      <p>Запись формата <span class="code">8 dup(?)</span> в первой лабораторной не
      фигурировала, так что следует пояснить её смысл. Первое число - количество повторений.
      dup - сокращение от duplicate. (?) - элемент, который надо будет повторять. Таким образом,
      <span class="code">array db 5 dup(0)</span> выделит 5 байт памяти и заполнит их нулями,
      <span class="code">array db 8 dup('A')</span> - 8 байт, каждый из которых равен коду символа
      'A', а <span class="code">array db 8 dup(?)</span> просто выделит память под 8 элементов
      массива, но прибираться там не станет, оставив мусор лежать на метафорическом полу
      нашей памяти.</p>
      <p>Появляется вполне закономерный вопрос: что все эти числа значат? У людей,
      уже посмотревших на само задание ко второй лабораторной, кроме этого вопроса
      возникает и другой: почему там фигурируют восьмёрки, если нам нужен массив из
      семи элементов?</p>
      <p>Это связано с той самой подковыристой структурой массива, в который будет
      записываться строка из консоли. Первый байт массива всегда содержит его "длину",
      если быть точным - максимальное число символов, которое разрешено ввести в консоль,
      включая символ-терминатор (в данном случае - перевод каретки по коду 13). Именно
      поэтому для массива из 7 элементов указывается длина 8. Второй байт мы оставляем
      неинициализированным, потому что его перезапишет сама вызванная процедура. В нём
      будет лежать число <i>действительно</i> введённых пользователем символов, <i>исключая</i>
      символ-ограничитель: введя в консоль "Hello", массив примет вид
      <span class="code">8, 5, 'h', 'e', 'l', 'l', 'o', 13, ?, ?</span>. После этого байта
      выделяется память уже непосредственно под элементы массива, объём выделенной памяти,
      по-хорошему, должен быть не меньше, чем число в первом байте (что очевидно).</p>
    </section>
    <section>
      <h2>Проверка числа на чётность</h2>
      <p>Вторым и, фактически, последним новым приёмом в этой лабораторной работе
      является проверка числа на чётность. В примере решения первого варианта
      проверка на чётность уже приведена:</p>
      <pre v-highlightjs><code class="x86asm">test [si], 1
jnz odd</code></pre>
      <p>Выглядит просто. За исключением одного "но". test - это кто вообще, и что он тут делает?
      Кто и зачем его сюда пустил? Говоря просто, test - анонимизированный AND, который
      спрятался за тремя слоями VPN и прокси и, как следствие, следов за собой почти не
      оставляет. Он производит побитовое "И" над операндами, но не изменяет ни одну из них.
      Вместо этого он развешивает флаги и уходит в закат. Проведя побитовое "И" числа с
      единицей, мы можем получить всего два различных результата: 0 и 1. Если
      в результате получился ноль, число, очевидно, чётное. Если единица - нечётное.
      Проверить это можно по флагу нуля ZF: <span class="code">jz</span> совершит
      переход при чётности числа, <span class="code">jnz</span> - при нечётности.</p>
      <p>Чисто технически, никто не мешает нам разделить число на 2 и, заигрывая,
      стрельнуть глазками в сторону регистра AH с остатком от деления, сравнив его
      с нулём. Примерно так бы мы и поступили в другом, высокоуровневом ЯП,
      но в Ассемблере для этого надо своими, вот этими вот руками в отдельный
      регистр упихнуть делитель, в AX упихнуть само число, провести деление,
      сравнить результат через cmp... Муторно, объёмно, долго и геморно.
      Зачем оно нам надо, если есть AND с единицей, который умещается в
      одну строку (две, если учитывать cmp) и не требует выделять под это приключение
      дополнительных регистров.</p>
    </section>
    <section>
      <h2>Вывод двузначного числа</h2>
      <p>Вернёмся к теме перевода двузначных чисел в строку. Это уже было разобрано в прошлой
      статье, но реитерация лишней не будет. Если число однозначное, космически сложная
      операция конверсии заключается в команде <span class="code">add num, 30h</span>,
      т.е. прибавлении к числу код-поинта символа нуля. Обратная конверсия, соответственно,
      реализуется через вычитание того же код-поинта. Если же число двузначное, нам придётся
      разделить его на десять и перевести как остаток, так и частное в символы. С трёхзначными
      будет ещё веселее, но это нам ещё не грозит. Это мы обсудим в разборе третьей лабы :)</p>
      <p>В целом, это нельзя назвать тяжёлой задачей. Раздражающей, нудной? Легко. Сложной?
      Не-а. Алгоритмика проста. Дополнительную головную боль в уравнение вносит тот факт,
      что мы заранее не знаем, сколько знаков в числе. Можно, конечно, просто вывести
      ноль в разряде десятков, но разве это интересно? Разве истинные погромизды стали бы
      так делать? Спойлер: ещё как стали бы. Но мы - не погромизды, мы гордые бауманцы
      без инстинкта самосохранения и какой-то внутренней логики, так что мы заморочимся.
      Мы сравним частное с нулём и в зависимости от этого решим, в какой символ
      записывать единицы, а оставшийся заполним пробелом. В итоге получится
      приблизительно такой код:</p>
      <pre v-highlightjs><code class="x86asm">string db ?, ' ', 13, 10, '$'
    ; Положим, что число расположено в bl
    xor ah, ah  ; Очищаем ah для корректного деления
    mov al, bl  ; Перемещаем содержимое bl в al для деления

    mov bl, 10  ; Делить на константу нельзя, заносим делитель в bl
    div bl  ; Совершаем деление на bl, ax делится на 10, в ah - остаток, в al - частное

    add ax, 3030h  ; Переводим оба числа в символы
    cmp al, 30h  ; Сравниваем уже не с нулём, а с символом нуля
    jz write_single_digit  ; если там ноль, переходим к записи однозначного числа

    mov string[0], al  ; Частное (десятки) в первый символ
    mov string[1], ah  ; Остаток (единицы) во второй символ
    jmp print  ; Пропустить блок с записью однозначного числа

write_single_digit:
    mov string[0], ah  ; Остаток (единицы) в первый символ
    ; Ну и всё собсна, в string[1] уже записан пробел, вывод будет чистенький-красивенький

print:
    lea dx, string
    mov ah, 9
    int 21h</code></pre>
    </section>
    <section>
      <h2>Разбор решения первого варианта</h2>
      <pre v-highlightjs><code class="x86asm">.MODEL small
.STACK 256
.DATA
prompt db 'Enter numeric array', 13, 10, '$'
array db 8, ?, dup(?)
sumStr db 13, 10, ?, 13, 10, '$'
.CODE
.STARTUP
    ; Вывод строки с запросом на ввод данных
    lea dx, prompt
    mov ah, 9h
    int 21h

    ; Подготовка к обработке массива
    mov cx, 7
    lea si, array[2]
    ; В оригинале в si записали array и сразу провели 2 инкремента, что является
    ; первым и основным признаком старческого маразма, не делайте так.
    mov al, 0  ; В al лежит сумма элементов

cycle:
    test [si], 1  ; Проверка на чётность
    jnz odd  ; Если значение нечётное, перейти к следующему

    ; Иначе прибавить к сумме и отнять 30h, чтобы перевести из символа в число
    add al, [si]
    sub al, 30h

odd:
    inc si
    loop cycle

    mov sumStr[2], al  ; Записать в строку вывода
    add sumStr[2], 30h  ; Перевести в символ

    ; Вывести на экран
    lea dx, sumStr
    mov ah, 9h
    int 21h</code></pre>
      <p>Если вы внимательно читали материал первой статьи и введение к этой статье, этот
      код будет вам более или менее понятен. В первом блоке мы просто уведомляем пользователя
      о том, что было бы просто офигенно ввести что-то в консольку. Во втором производится
      буферизованный ввод, описанный выше в статье - записываем в DX адрес массива,
      в который запишутся данные, вызываем сервис с кодом 0Ah, сервис заглядывает в первый
      элемент массива, читает оттуда восьмёрку и дожидается от пользователя ввода
      вплоть до семи значимых символов + терминатор (перевод каретки, '\r', 13).
      В оригинале кода, как я отметил в комментариях, адрес в SI записывается как-то
      по-китайски, не делайте так - два инкремента ни по производительности, ни по
      читаемости не дотягивают до лаконичного array[2], которое ещё и заменяется
      на единственную числовую константу с применённым сдвигом при сборке программы.
      Вывод: не делайте так, это ущербное зрелище, пг/ам (пример плохой, автор нехороший человек).</p>
      <p>Далее идёт вполне стандартная аккумуляция суммы в регистре AL, объяснять
      которую не вижу смысла. Проверка на чётность проводится описанным выше способом,
      через побитовый "И" с элемента массива с единицей и проверку флага ZF. После цикла
      производится запись результата в строку вывода и, в завершение Марлезонского балета,
      непосредственно сам вывод. Строка вывода начинается с символов 13 и 10, чтобы обеспечить
      вывод с новой строки, после пользовательского ввода.</p>
    </section>
    <section>
      <h2>Разбор вариантов задания</h2>
      <p>Ну вот, вообще не страшно, в этот раз - действительно, а не как в прошлый. Теперь
      пробежимся по вариантам, они вновь парные. Первый вариант от разобранного решения
      не отличается никак, потому что он, собственно, и разобран. Второй вариант снова
      отличается одним символом: так как требуется найти сумму нечётных элементов,
      jnz меняется на jz. Третий и четвёртый варианты совпадают с первым и вторым
      соответственно за одним исключением: нужна сумма порядковых номеров. Реализуется это
      аналогично реализации этих вариантов в первой лабораторной: порядковый номер есть
      длина массива+1 минус содержимое CX, просто в этот раз вместо перезаписи нам нужна
      сумма, а значит mov меняется на add:</p>
      <pre v-highlightjs><code class="x86asm">    mov al, 0
cycle:
    test [si], 1
    jnz odd
    ;; Новый код
    add al, 8  ; Прибавляем к сумме длину массива+1
    sub al, cl  ; Вычитаем содержимое cl, чтобы получить порядковый номер
    ;; Опять старый код
odd:
    inc si</code></pre>
      <p>Варианты 5-10 получают пощёчину в виде дополнительно введённых двух
      цифр, задающих ограничивающий диапазон. Для этого нужно ввести новый массив,
      точно так же считать в него цифры через буферизованный ввод и проверять числа
      на вхождение в диапазон знакомыми нам по первой лабе ja, jb:</p>
      <pre v-highlightjs><code class="x86asm">range db 3, ?, 3 dup(?)

    lea dx, range[2]
    mov ah, 0Ah
    int 21h
    ...
    ; Заносим диапазон в регистр AX для удобства
    mov al, range[0]
    mov ah, range[1]
    mov bl, 0  ; Положим, сумма будет в bl
cycle:
    cmp [si], ah
    jb next  ; Меньше нижней границы, пропускаем
    cmp [si], al
    ja next  ; Больше верхней границы, пропускаем
    ; Входит в диапазон, работаем
    add bl, [si]
    sub bl, 30h
next:
    inc si
    loop cycle
    ...</code></pre>
      <p>Варианты 6-8 требуют вывести на консоль сразу несколько порядковых номеров.
      Сделать это можно примитивным способом, просто перезаписывая данные в строку вывода
      и вызывая процедуру вывода на экран - я не вижу смысла это как-то пояснять. То же,
      на самом деле, касается вариантов 9 и 10, которые просто являются вариациями уже
      разобранных и решённых задач. Вот и всё. В качестве конфетки в конце привожу
      своё (хоть и несколько устаревшее, сейчас я решил бы задачу чуть-чуть иначе) решение девятого
      варианта и крайне наивно рассчитываю на то, что ни у кого не хватит наглости
      скопировать его символ-в-символ, вырезая комментарии и пустое пространство. Удачного
      выполнения, не бойтесь обращаться с вопросами и до встречи в разборе следующей лабы.</p>
      <pre v-highlightjs><code class="x86asm">;; Считать с клавиатуры цифровой массив, вывести сумму
;; индексов чётных элементов, которые входят в указанный
;; пользователем диапазон

.MODEL small
.STACK 256
ARRAY_LENGTH equ 7
ARRAY_CAPACITY equ ARRAY_LENGTH + 1

.DATA
arrayPromptStr db 'Enter numeric array (7 digits): $'

; Первый элемент (8) - максимальное число символов для ввода (с учётом терминатора)
; Во второй элемент (?) будет записано число реально введённых символов
; Затем идут 7 неинициализированных элементов (сами элементы массива)
; И восьмой элемент для символа-терминатора
array db ARRAY_CAPACITY, ?, ARRAY_CAPACITY dup(?)

rangePromptStr db 13, 10, 'Enter acceptable value range (2 digits): $'
; Аналогично, массив из двух цифр, ограничивающих диапазон для вычисления
range db 3, ?, 3 dup(?)

outputAnnotationStr db 13, 10, 'Sum of positions of even elements within range: $'
outputStr db ?, ' ', 13, 10, '$'
.CODE
.STARTUP
; Запрос на ввод данных
    lea dx, arrayPromptStr
    mov ah, 9h
    int 21h

; Буферизованный ввод
    lea dx, array
    mov ah, 0Ah
    int 21h

; Запрос на ввод ограничительного диапазона
    lea dx, rangePromptStr
    mov ah, 9h
    int 21h

; Ввод ограничительного диапазона
    lea dx, range
    mov ah, 0Ah
    int 21h

; Подготовка к циклу
    mov cx, ARRAY_LENGTH
    mov al, 0  ; Сумма будет хранится в al
    lea si, array[2]  ; Записываем адрес первого элемента массива в si

; Обход элементов массива
cycle:
    ; Перевод из символа в число совершать не обязательно, т.к. чётность сохраняется
    test BYTE PTR[si], 1  ; Тест выполняет побитовый AND, но не изменяет операнды
    jnz next  ; Если число нечётное, пропустить увеличение суммы

    ; Проверка на вхождение в диапазон
    ; Записываем содержимое диапазона в регистры для использования cmp
    mov bh, range[2]
    mov bl, range[3]
    cmp [si], bh
    jb next
    cmp [si], bl
    ja next

    ; Вычисление порядкового номера и увеличение суммы
    mov bx, ARRAY_CAPACITY  ; Требуется номер, а не индекс, => CAPACITY
    sub bx, cx
    add al, bl
next:
    inc si
    loop cycle

; Перевод суммы в строковый вид
    cmp al, 9
    ja convert_double_digits
    ; Для однозначного числа
    add al, 30h
    mov outputStr[0], al
    jmp print

convert_double_digits:
    ; Для двузначного числа
    mov ah, 0  ; Очищаем старший байт AX для корректного деления
    mov bx, 10
    div bl  ; AL - частное, AH - остаток

    add ax, 3030h  ; Перевод в символы
    mov outputStr[0], al
    mov outputStr[1], ah

; Вывод результата
print:
    lea dx, outputAnnotationStr
    mov ah, 9h
    int 21h

    lea dx, outputStr
    int 21h
.EXIT
END</code></pre>
    </section>
  </div>
</template>

<script>
export default {
name: "asm-lab2"
}
</script>

<style scoped>

</style>