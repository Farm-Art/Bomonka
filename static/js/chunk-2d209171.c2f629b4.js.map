{"version":3,"sources":["webpack:///./src/views/asm-lab2.vue?e2a4","webpack:///src/views/asm-lab2.vue","webpack:///./src/views/asm-lab2.vue?b425","webpack:///./src/views/asm-lab2.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","_v","directives","name","rawName","staticClass","_m","staticRenderFns","component"],"mappings":"uHAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACA,EAAG,cAAc,CAACE,MAAM,CAAC,GAAK,iBAAiB,CAACF,EAAG,KAAK,CAACJ,EAAIO,GAAG,yCAAyCH,EAAG,KAAK,CAACJ,EAAIO,GAAG,oGAAoGH,EAAG,UAAU,CAACA,EAAG,KAAK,CAACJ,EAAIO,GAAG,2BAA2BH,EAAG,IAAI,CAACJ,EAAIO,GAAG,sCAAsCH,EAAG,cAAc,CAACE,MAAM,CAAC,GAAK,qBAAqB,CAACN,EAAIO,GAAG,iCAAiCP,EAAIO,GAAG,shBAAshB,GAAGH,EAAG,IAAI,CAACJ,EAAIO,GAAG,0YAA4YH,EAAG,IAAI,CAACJ,EAAIO,GAAG,6BAA6BH,EAAG,UAAU,CAACA,EAAG,KAAK,CAACJ,EAAIO,GAAG,gCAAgCH,EAAG,IAAI,CAACJ,EAAIO,GAAG,6HAA6HH,EAAG,MAAM,CAACI,WAAW,CAAC,CAACC,KAAK,cAAcC,QAAQ,mBAAmB,CAACN,EAAG,OAAO,CAACO,YAAY,UAAU,CAACX,EAAIO,GAAG,0KAA0KP,EAAIY,GAAG,GAAGR,EAAG,MAAM,CAACI,WAAW,CAAC,CAACC,KAAK,cAAcC,QAAQ,mBAAmB,CAACN,EAAG,OAAO,CAACO,YAAY,UAAU,CAACX,EAAIO,GAAG,sEAAsEP,EAAIY,GAAG,GAAGR,EAAG,IAAI,CAACJ,EAAIO,GAAG,0PAA0PP,EAAIY,GAAG,KAAKR,EAAG,UAAU,CAACA,EAAG,KAAK,CAACJ,EAAIO,GAAG,gCAAgCH,EAAG,IAAI,CAACJ,EAAIO,GAAG,0LAA0LH,EAAG,MAAM,CAACI,WAAW,CAAC,CAACC,KAAK,cAAcC,QAAQ,mBAAmB,CAACN,EAAG,OAAO,CAACO,YAAY,UAAU,CAACX,EAAIO,GAAG,6BAA6BP,EAAIY,GAAG,GAAGR,EAAG,IAAI,CAACJ,EAAIO,GAAG,imBAAimBH,EAAG,UAAU,CAACA,EAAG,KAAK,CAACJ,EAAIO,GAAG,6BAA6BP,EAAIY,GAAG,GAAGR,EAAG,IAAI,CAACJ,EAAIO,GAAG,8pBAA8pBH,EAAG,MAAM,CAACI,WAAW,CAAC,CAACC,KAAK,cAAcC,QAAQ,mBAAmB,CAACN,EAAG,OAAO,CAACO,YAAY,UAAU,CAACX,EAAIO,GAAG,k9BAAk9BH,EAAG,UAAU,CAACA,EAAG,KAAK,CAACJ,EAAIO,GAAG,qCAAqCH,EAAG,MAAM,CAACI,WAAW,CAAC,CAACC,KAAK,cAAcC,QAAQ,mBAAmB,CAACN,EAAG,OAAO,CAACO,YAAY,UAAU,CAACX,EAAIO,GAAG,08BAA08BH,EAAG,IAAI,CAACJ,EAAIO,GAAG,i9BAAi9BH,EAAG,IAAI,CAACJ,EAAIO,GAAG,udAAydH,EAAG,UAAU,CAACA,EAAG,KAAK,CAACJ,EAAIO,GAAG,8BAA8BH,EAAG,IAAI,CAACJ,EAAIO,GAAG,krBAAkrBH,EAAG,MAAM,CAACI,WAAW,CAAC,CAACC,KAAK,cAAcC,QAAQ,mBAAmB,CAACN,EAAG,OAAO,CAACO,YAAY,UAAU,CAACX,EAAIO,GAAG,yPAAyPH,EAAG,IAAI,CAACJ,EAAIO,GAAG,iSAAiSH,EAAG,MAAM,CAACI,WAAW,CAAC,CAACC,KAAK,cAAcC,QAAQ,mBAAmB,CAACN,EAAG,OAAO,CAACO,YAAY,UAAU,CAACX,EAAIO,GAAG,weAAweH,EAAG,IAAI,CAACJ,EAAIO,GAAG,2uBAA2uBH,EAAG,MAAM,CAACI,WAAW,CAAC,CAACC,KAAK,cAAcC,QAAQ,mBAAmB,CAACN,EAAG,OAAO,CAACO,YAAY,UAAU,CAACX,EAAIO,GAAG,kqFAAkqF,IAChzaM,EAAkB,CAAC,WAAa,IAAIb,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,IAAI,CAACJ,EAAIO,GAAG,8EAA8EH,EAAG,OAAO,CAACO,YAAY,QAAQ,CAACX,EAAIO,GAAG,iBAAiBP,EAAIO,GAAG,OAAOH,EAAG,OAAO,CAACO,YAAY,QAAQ,CAACX,EAAIO,GAAG,aAAaP,EAAIO,GAAG,uPAAuPH,EAAG,IAAI,CAACJ,EAAIO,GAAG,WAAWP,EAAIO,GAAG,yLAAyL,WAAa,IAAIP,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,IAAI,CAACJ,EAAIO,GAAG,mBAAmBH,EAAG,OAAO,CAACO,YAAY,QAAQ,CAACX,EAAIO,GAAG,cAAcP,EAAIO,GAAG,gNAAgNH,EAAG,OAAO,CAACO,YAAY,QAAQ,CAACX,EAAIO,GAAG,uBAAuBP,EAAIO,GAAG,iDAAiDH,EAAG,OAAO,CAACO,YAAY,QAAQ,CAACX,EAAIO,GAAG,yBAAyBP,EAAIO,GAAG,2DAA2DH,EAAG,OAAO,CAACO,YAAY,QAAQ,CAACX,EAAIO,GAAG,uBAAuBP,EAAIO,GAAG,8IAA8I,WAAa,IAAIP,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,IAAI,CAACJ,EAAIO,GAAG,yfAA2fH,EAAG,IAAI,CAACJ,EAAIO,GAAG,mBAAmBP,EAAIO,GAAG,uCAAuCH,EAAG,IAAI,CAACJ,EAAIO,GAAG,cAAcP,EAAIO,GAAG,qEAAuEH,EAAG,OAAO,CAACO,YAAY,QAAQ,CAACX,EAAIO,GAAG,6CAA6CP,EAAIO,GAAG,4LAA4L,WAAa,IAAIP,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,IAAI,CAACJ,EAAIO,GAAG,smBAA4mBH,EAAG,OAAO,CAACO,YAAY,QAAQ,CAACX,EAAIO,GAAG,QAAQP,EAAIO,GAAG,0CAA0CH,EAAG,OAAO,CAACO,YAAY,QAAQ,CAACX,EAAIO,GAAG,SAASP,EAAIO,GAAG,yBAAyB,WAAa,IAAIP,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,IAAI,CAACJ,EAAIO,GAAG,oNAAoNH,EAAG,OAAO,CAACO,YAAY,QAAQ,CAACX,EAAIO,GAAG,kBAAkBP,EAAIO,GAAG,qWCyWx4H,GACAE,KAAA,YC3WkV,I,YCO9UK,EAAY,eACd,EACAf,EACAc,GACA,EACA,KACA,WACA,MAIa,aAAAC,E","file":"static/js/chunk-2d209171.c2f629b4.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('router-link',{attrs:{\"to\":\"/guides/asm/\"}},[_c('h5',[_vm._v(\"<- Вертай в зад, обратно к гайдам\")])]),_c('h1',[_vm._v(\"Ассемблер. Буферизованный ввод. Проверка числа на чётность. Разбор второй лабораторной работы.\")]),_c('section',[_c('h2',[_vm._v(\"Небольшое предисловие\")]),_c('p',[_vm._v(\"Если вы внимательно читали разбор \"),_c('router-link',{attrs:{\"to\":\"/guides/asm/lab1\"}},[_vm._v(\" первой лабораторной работы\")]),_vm._v(\", в этой статье для вас новой информации практически не будет, как, собственно, и в последующих. Первая статья выполняет роль порога вхождения в Ассемблер. Её просто нужно переступить, после неё каких-то кардинально новых концептов появляться не будет. Главное - понять основные принципы работы с Ассемблером. Если же вы ещё не прочитали ту статью (или читали невнимательно, или же пропускали куски), настоятельно рекомендую это сделать сейчас, в идеале следуя за инструкциями в реальном времени, чтобы сразу закрепить изученное.\")],1),_c('p',[_vm._v(\"Сегодня мы изучим ввод не одного символа, а целой строки из консоли, рассмотрим проверку чисел на чётность и повторно разберём перевод двузначных чисел в символьный вид, ибо теперь он фигурирует во всех вариантах, а я могу с уверенностью сказать, что приличная доля читающих смело игнорирует мои рекомендации. Как выразился один мой близкий друг, \\\"Я, конечно, гордый, но повторю ещё раз\\\".\")]),_c('p',[_vm._v(\"Ну что же, приступим!\")])]),_c('section',[_c('h2',[_vm._v(\"Буферизованный ввод данных\")]),_c('p',[_vm._v(\"Буферизованные ввод и вывод данных через консоль реализуются практически одинаково. Вспомним, как осуществляется вывод:\")]),_c('pre',{directives:[{name:\"highlightjs\",rawName:\"v-highlightjs\"}]},[_c('code',{staticClass:\"x86asm\"},[_vm._v(\"string db 'Hello, world!', 13, 10, '$'\\n\\nlea dx, string  ; Загрузка адреса в dx\\nmov ah, 9  ; Установка кода операции вывода строки\\nint 21h  ; Вызов сервиса DOS\")])]),_vm._m(0),_c('pre',{directives:[{name:\"highlightjs\",rawName:\"v-highlightjs\"}]},[_c('code',{staticClass:\"x86asm\"},[_vm._v(\"array db 8, ?, 8 dup(?)\\n\\nlea dx, array\\nmov ah, 0Ah\\nint 21h\")])]),_vm._m(1),_c('p',[_vm._v(\"Появляется вполне закономерный вопрос: что все эти числа значат? У людей, уже посмотревших на само задание ко второй лабораторной, кроме этого вопроса возникает и другой: почему там фигурируют восьмёрки, если нам нужен массив из семи элементов?\")]),_vm._m(2)]),_c('section',[_c('h2',[_vm._v(\"Проверка числа на чётность\")]),_c('p',[_vm._v(\"Вторым и, фактически, последним новым приёмом в этой лабораторной работе является проверка числа на чётность. В примере решения первого варианта проверка на чётность уже приведена:\")]),_c('pre',{directives:[{name:\"highlightjs\",rawName:\"v-highlightjs\"}]},[_c('code',{staticClass:\"x86asm\"},[_vm._v(\"test [si], 1\\njnz odd\")])]),_vm._m(3),_c('p',[_vm._v(\"Чисто технически, никто не мешает нам разделить число на 2 и, заигрывая, стрельнуть глазками в сторону регистра AH с остатком от деления, сравнив его с нулём. Примерно так бы мы и поступили в другом, высокоуровневом ЯП, но в Ассемблере для этого надо своими, вот этими вот руками в отдельный регистр упихнуть делитель, в AX упихнуть само число, провести деление, сравнить результат через cmp... Муторно, объёмно, долго и геморно. Зачем оно нам надо, если есть AND с единицей, который умещается в одну строку (две, если учитывать cmp) и не требует выделять под это приключение дополнительных регистров.\")])]),_c('section',[_c('h2',[_vm._v(\"Вывод двузначного числа\")]),_vm._m(4),_c('p',[_vm._v(\"В целом, это нельзя назвать тяжёлой задачей. Раздражающей, нудной? Легко. Сложной? Не-а. Алгоритмика проста. Дополнительную головную боль в уравнение вносит тот факт, что мы заранее не знаем, сколько знаков в числе. Можно, конечно, просто вывести ноль в разряде десятков, но разве это интересно? Разве истинные погромизды стали бы так делать? Спойлер: ещё как стали бы. Но мы - не погромизды, мы гордые бауманцы без инстинкта самосохранения и какой-то внутренней логики, так что мы заморочимся. Мы сравним частное с нулём и в зависимости от этого решим, в какой символ записывать единицы, а оставшийся заполним пробелом. В итоге получится приблизительно такой код:\")]),_c('pre',{directives:[{name:\"highlightjs\",rawName:\"v-highlightjs\"}]},[_c('code',{staticClass:\"x86asm\"},[_vm._v(\"string db ?, ' ', 13, 10, '$'\\n    ; Положим, что число расположено в bl\\n    xor ah, ah  ; Очищаем ah для корректного деления\\n    mov al, bl  ; Перемещаем содержимое bl в al для деления\\n\\n    mov bl, 10  ; Делить на константу нельзя, заносим делитель в bl\\n    div bl  ; Совершаем деление на bl, ax делится на 10, в ah - остаток, в al - частное\\n\\n    add ax, 3030h  ; Переводим оба числа в символы\\n    cmp al, 30h  ; Сравниваем уже не с нулём, а с символом нуля\\n    jz write_single_digit  ; если там ноль, переходим к записи однозначного числа\\n\\n    mov string[0], al  ; Частное (десятки) в первый символ\\n    mov string[1], ah  ; Остаток (единицы) во второй символ\\n    jmp print  ; Пропустить блок с записью однозначного числа\\n\\nwrite_single_digit:\\n    mov string[0], ah  ; Остаток (единицы) в первый символ\\n    ; Ну и всё собсна, в string[1] уже записан пробел, вывод будет чистенький-красивенький\\n\\nprint:\\n    lea dx, string\\n    mov ah, 9\\n    int 21h\")])])]),_c('section',[_c('h2',[_vm._v(\"Разбор решения первого варианта\")]),_c('pre',{directives:[{name:\"highlightjs\",rawName:\"v-highlightjs\"}]},[_c('code',{staticClass:\"x86asm\"},[_vm._v(\".MODEL small\\n.STACK 256\\n.DATA\\nprompt db 'Enter numeric array', 13, 10, '$'\\narray db 8, ?, dup(?)\\nsumStr db 13, 10, ?, 13, 10, '$'\\n.CODE\\n.STARTUP\\n    ; Вывод строки с запросом на ввод данных\\n    lea dx, prompt\\n    mov ah, 9h\\n    int 21h\\n\\n    ; Подготовка к обработке массива\\n    mov cx, 7\\n    lea si, array[2]\\n    ; В оригинале в si записали array и сразу провели 2 инкремента, что является\\n    ; первым и основным признаком старческого маразма, не делайте так.\\n    mov al, 0  ; В al лежит сумма элементов\\n\\ncycle:\\n    test [si], 1  ; Проверка на чётность\\n    jnz odd  ; Если значение нечётное, перейти к следующему\\n\\n    ; Иначе прибавить к сумме и отнять 30h, чтобы перевести из символа в число\\n    add al, [si]\\n    sub al, 30h\\n\\nodd:\\n    inc si\\n    loop cycle\\n\\n    mov sumStr[2], al  ; Записать в строку вывода\\n    add sumStr[2], 30h  ; Перевести в символ\\n\\n    ; Вывести на экран\\n    lea dx, sumStr\\n    mov ah, 9h\\n    int 21h\")])]),_c('p',[_vm._v(\"Если вы внимательно читали материал первой статьи и введение к этой статье, этот код будет вам более или менее понятен. В первом блоке мы просто уведомляем пользователя о том, что было бы просто офигенно ввести что-то в консольку. Во втором производится буферизованный ввод, описанный выше в статье - записываем в DX адрес массива, в который запишутся данные, вызываем сервис с кодом 0Ah, сервис заглядывает в первый элемент массива, читает оттуда восьмёрку и дожидается от пользователя ввода вплоть до семи значимых символов + терминатор (перевод каретки, '\\\\r', 13). В оригинале кода, как я отметил в комментариях, адрес в SI записывается как-то по-китайски, не делайте так - два инкремента ни по производительности, ни по читаемости не дотягивают до лаконичного array[2], которое ещё и заменяется на единственную числовую константу с применённым сдвигом при сборке программы. Вывод: не делайте так, это ущербное зрелище, пг/ам (пример плохой, автор нехороший человек).\")]),_c('p',[_vm._v(\"Далее идёт вполне стандартная аккумуляция суммы в регистре AL, объяснять которую не вижу смысла. Проверка на чётность проводится описанным выше способом, через побитовый \\\"И\\\" с элемента массива с единицей и проверку флага ZF. После цикла производится запись результата в строку вывода и, в завершение Марлезонского балета, непосредственно сам вывод. Строка вывода начинается с символов 13 и 10, чтобы обеспечить вывод с новой строки, после пользовательского ввода.\")])]),_c('section',[_c('h2',[_vm._v(\"Разбор вариантов задания\")]),_c('p',[_vm._v(\"Ну вот, вообще не страшно, в этот раз - действительно, а не как в прошлый. Теперь пробежимся по вариантам, они вновь парные. Первый вариант от разобранного решения не отличается никак, потому что он, собственно, и разобран. Второй вариант снова отличается одним символом: так как требуется найти сумму нечётных элементов, jnz меняется на jz. Третий и четвёртый варианты совпадают с первым и вторым соответственно за одним исключением: нужна сумма порядковых номеров. Реализуется это аналогично реализации этих вариантов в первой лабораторной: порядковый номер есть длина массива+1 минус содержимое CX, просто в этот раз вместо перезаписи нам нужна сумма, а значит mov меняется на add:\")]),_c('pre',{directives:[{name:\"highlightjs\",rawName:\"v-highlightjs\"}]},[_c('code',{staticClass:\"x86asm\"},[_vm._v(\"    mov al, 0\\ncycle:\\n    test [si], 1\\n    jnz odd\\n    ;; Новый код\\n    add al, 8  ; Прибавляем к сумме длину массива+1\\n    sub al, cl  ; Вычитаем содержимое cl, чтобы получить порядковый номер\\n    ;; Опять старый код\\nodd:\\n    inc si\")])]),_c('p',[_vm._v(\"Варианты 5-10 получают пощёчину в виде дополнительно введённых двух цифр, задающих ограничивающий диапазон. Для этого нужно ввести новый массив, точно так же считать в него цифры через буферизованный ввод и проверять числа на вхождение в диапазон знакомыми нам по первой лабе ja, jb:\")]),_c('pre',{directives:[{name:\"highlightjs\",rawName:\"v-highlightjs\"}]},[_c('code',{staticClass:\"x86asm\"},[_vm._v(\"range db 3, ?, 3 dup(?)\\n\\n    lea dx, range\\n    mov ah, 0Ah\\n    int 21h\\n    ...\\n    ; Заносим диапазон в регистр AX для удобства\\n    mov al, range[2]\\n    mov ah, range[3]\\n    mov bl, 0  ; Положим, сумма будет в bl\\ncycle:\\n    cmp [si], ah\\n    jb next  ; Меньше нижней границы, пропускаем\\n    cmp [si], al\\n    ja next  ; Больше верхней границы, пропускаем\\n    ; Входит в диапазон, работаем\\n    add bl, [si]\\n    sub bl, 30h\\nnext:\\n    inc si\\n    loop cycle\\n    ...\")])]),_c('p',[_vm._v(\"Варианты 6-8 требуют вывести на консоль сразу несколько порядковых номеров. Сделать это можно примитивным способом, просто перезаписывая данные в строку вывода и вызывая процедуру вывода на экран - я не вижу смысла это как-то пояснять. То же, на самом деле, касается вариантов 9 и 10, которые просто являются вариациями уже разобранных и решённых задач. Вот и всё. В качестве конфетки в конце привожу своё (хоть и несколько устаревшее, сейчас я решил бы задачу чуть-чуть иначе) решение девятого варианта и крайне наивно рассчитываю на то, что ни у кого не хватит наглости скопировать его символ-в-символ, вырезая комментарии и пустое пространство. Удачного выполнения, не бойтесь обращаться с вопросами и до встречи в разборе следующей лабы.\")]),_c('pre',{directives:[{name:\"highlightjs\",rawName:\"v-highlightjs\"}]},[_c('code',{staticClass:\"x86asm\"},[_vm._v(\";; Считать с клавиатуры цифровой массив, вывести сумму\\n;; индексов чётных элементов, которые входят в указанный\\n;; пользователем диапазон\\n\\n.MODEL small\\n.STACK 256\\nARRAY_LENGTH equ 7\\nARRAY_CAPACITY equ ARRAY_LENGTH + 1\\n\\n.DATA\\narrayPromptStr db 'Enter numeric array (7 digits): $'\\n\\n; Первый элемент (8) - максимальное число символов для ввода (с учётом терминатора)\\n; Во второй элемент (?) будет записано число реально введённых символов\\n; Затем идут 7 неинициализированных элементов (сами элементы массива)\\n; И восьмой элемент для символа-терминатора\\narray db ARRAY_CAPACITY, ?, ARRAY_CAPACITY dup(?)\\n\\nrangePromptStr db 13, 10, 'Enter acceptable value range (2 digits): $'\\n; Аналогично, массив из двух цифр, ограничивающих диапазон для вычисления\\nrange db 3, ?, 3 dup(?)\\n\\noutputAnnotationStr db 13, 10, 'Sum of positions of even elements within range: $'\\noutputStr db ?, ' ', 13, 10, '$'\\n.CODE\\n.STARTUP\\n; Запрос на ввод данных\\n    lea dx, arrayPromptStr\\n    mov ah, 9h\\n    int 21h\\n\\n; Буферизованный ввод\\n    lea dx, array\\n    mov ah, 0Ah\\n    int 21h\\n\\n; Запрос на ввод ограничительного диапазона\\n    lea dx, rangePromptStr\\n    mov ah, 9h\\n    int 21h\\n\\n; Ввод ограничительного диапазона\\n    lea dx, range\\n    mov ah, 0Ah\\n    int 21h\\n\\n; Подготовка к циклу\\n    mov cx, ARRAY_LENGTH\\n    mov al, 0  ; Сумма будет хранится в al\\n    lea si, array[2]  ; Записываем адрес первого элемента массива в si\\n\\n; Обход элементов массива\\ncycle:\\n    ; Перевод из символа в число совершать не обязательно, т.к. чётность сохраняется\\n    test BYTE PTR[si], 1  ; Тест выполняет побитовый AND, но не изменяет операнды\\n    jnz next  ; Если число нечётное, пропустить увеличение суммы\\n\\n    ; Проверка на вхождение в диапазон\\n    ; Записываем содержимое диапазона в регистры для использования cmp\\n    mov bh, range[2]\\n    mov bl, range[3]\\n    cmp [si], bh\\n    jb next\\n    cmp [si], bl\\n    ja next\\n\\n    ; Вычисление порядкового номера и увеличение суммы\\n    mov bx, ARRAY_CAPACITY  ; Требуется номер, а не индекс, => CAPACITY\\n    sub bx, cx\\n    add al, bl\\nnext:\\n    inc si\\n    loop cycle\\n\\n; Перевод суммы в строковый вид\\n    cmp al, 9\\n    ja convert_double_digits\\n    ; Для однозначного числа\\n    add al, 30h\\n    mov outputStr[0], al\\n    jmp print\\n\\nconvert_double_digits:\\n    ; Для двузначного числа\\n    mov ah, 0  ; Очищаем старший байт AX для корректного деления\\n    mov bx, 10\\n    div bl  ; AL - частное, AH - остаток\\n\\n    add ax, 3030h  ; Перевод в символы\\n    mov outputStr[0], al\\n    mov outputStr[1], ah\\n\\n; Вывод результата\\nprint:\\n    lea dx, outputAnnotationStr\\n    mov ah, 9h\\n    int 21h\\n\\n    lea dx, outputStr\\n    int 21h\\n.EXIT\\nEND\")])])])],1)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('p',[_vm._v(\"Как вы, надеюсь, помните (ибо конструкция действительно фундаментальная), \"),_c('span',{staticClass:\"code\"},[_vm._v(\"mov ah, КОД\")]),_vm._v(\" и \"),_c('span',{staticClass:\"code\"},[_vm._v(\"int 21h\")]),_vm._v(\" вместе осуществляют вызов некоторой системной процедуры, определяемой записанным в AH кодом. В случае с 9, по адресу из регистра DX будет выведена строка символов вплоть до символа-ограничителя, которым служит знак доллара ('$'). Операция же \"),_c('i',[_vm._v(\"ввода\")]),_vm._v(\" строки соответствует коду 0Ah, который запишет введённую в консоль строку в массив по адресу, опять-таки лежащему в DX. При этом сам массив будет иметь несколько иную структуру:\")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('p',[_vm._v(\"Запись формата \"),_c('span',{staticClass:\"code\"},[_vm._v(\"8 dup(?)\")]),_vm._v(\" в первой лабораторной не фигурировала, так что следует пояснить её смысл. Первое число - количество повторений. dup - сокращение от duplicate. (?) - элемент, который надо будет повторять. Таким образом, \"),_c('span',{staticClass:\"code\"},[_vm._v(\"array db 5 dup(0)\")]),_vm._v(\" выделит 5 байт памяти и заполнит их нулями, \"),_c('span',{staticClass:\"code\"},[_vm._v(\"array db 8 dup('A')\")]),_vm._v(\" - 8 байт, каждый из которых равен коду символа 'A', а \"),_c('span',{staticClass:\"code\"},[_vm._v(\"array db 8 dup(?)\")]),_vm._v(\" просто выделит память под 8 элементов массива, но прибираться там не станет, оставив мусор лежать на метафорическом полу нашей памяти.\")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('p',[_vm._v(\"Это связано с той самой подковыристой структурой массива, в который будет записываться строка из консоли. Первый байт массива всегда содержит его \\\"длину\\\", если быть точным - максимальное число символов, которое разрешено ввести в консоль, включая символ-терминатор (в данном случае - перевод каретки по коду 13). Именно поэтому для массива из 7 элементов указывается длина 8. Второй байт мы оставляем неинициализированным, потому что его перезапишет сама вызванная процедура. В нём будет лежать число \"),_c('i',[_vm._v(\"действительно\")]),_vm._v(\" введённых пользователем символов, \"),_c('i',[_vm._v(\"исключая\")]),_vm._v(\" символ-ограничитель: введя в консоль \\\"Hello\\\", массив примет вид \"),_c('span',{staticClass:\"code\"},[_vm._v(\"8, 5, 'h', 'e', 'l', 'l', 'o', 13, ?, ?\")]),_vm._v(\". После этого байта выделяется память уже непосредственно под элементы массива, объём выделенной памяти, по-хорошему, должен быть не меньше, чем число в первом байте (что очевидно).\")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('p',[_vm._v(\"Выглядит просто. За исключением одного \\\"но\\\". test - это кто вообще, и что он тут делает? Кто и зачем его сюда пустил? Говоря просто, test - анонимизированный AND, который спрятался за тремя слоями VPN и прокси и, как следствие, следов за собой почти не оставляет. Он производит побитовое \\\"И\\\" над операндами, но не изменяет ни одну из них. Вместо этого он развешивает флаги и уходит в закат. Проведя побитовое \\\"И\\\" числа с единицей, мы можем получить всего два различных результата: 0 и 1. Если в результате получился ноль, число, очевидно, чётное. Если единица - нечётное. Проверить это можно по флагу нуля ZF: \"),_c('span',{staticClass:\"code\"},[_vm._v(\"jz\")]),_vm._v(\" совершит переход при чётности числа, \"),_c('span',{staticClass:\"code\"},[_vm._v(\"jnz\")]),_vm._v(\" - при нечётности.\")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('p',[_vm._v(\"Вернёмся к теме перевода двузначных чисел в строку. Это уже было разобрано в прошлой статье, но реитерация лишней не будет. Если число однозначное, космически сложная операция конверсии заключается в команде \"),_c('span',{staticClass:\"code\"},[_vm._v(\"add num, 30h\")]),_vm._v(\", т.е. прибавлении к числу код-поинта символа нуля. Обратная конверсия, соответственно, реализуется через вычитание того же код-поинта. Если же число двузначное, нам придётся разделить его на десять и перевести как остаток, так и частное в символы. С трёхзначными будет ещё веселее, но это нам ещё не грозит. Это мы обсудим в разборе третьей лабы :)\")])}]\n\nexport { render, staticRenderFns }","<template>\r\n  <div>\r\n    <router-link to=\"/guides/asm/\"><h5>&lt;- Вертай в зад, обратно к гайдам</h5></router-link>\r\n    <h1>Ассемблер. Буферизованный ввод. Проверка числа на чётность. Разбор\r\n    второй лабораторной работы.</h1>\r\n    <section>\r\n      <h2>Небольшое предисловие</h2>\r\n      <p>Если вы внимательно читали разбор <router-link to=\"/guides/asm/lab1\">\r\n      первой лабораторной работы</router-link>, в этой статье для вас новой информации\r\n      практически не будет, как, собственно, и в последующих. Первая статья выполняет\r\n      роль порога вхождения в Ассемблер. Её просто нужно переступить, после неё\r\n      каких-то кардинально новых концептов появляться не будет. Главное - понять\r\n      основные принципы работы с Ассемблером. Если же вы ещё не прочитали\r\n      ту статью (или читали невнимательно, или же пропускали куски),\r\n      настоятельно рекомендую это сделать сейчас, в идеале следуя за инструкциями\r\n      в реальном времени, чтобы сразу закрепить изученное.</p>\r\n      <p>Сегодня мы изучим ввод не одного символа, а целой строки из консоли,\r\n      рассмотрим проверку чисел на чётность и повторно разберём перевод\r\n      двузначных чисел в символьный вид, ибо теперь он фигурирует во всех вариантах,\r\n      а я могу с уверенностью сказать, что приличная доля читающих смело игнорирует\r\n      мои рекомендации. Как выразился один мой близкий друг, \"Я, конечно, гордый,\r\n      но повторю ещё раз\".</p>\r\n      <p>Ну что же, приступим!</p>\r\n    </section>\r\n    <section>\r\n      <h2>Буферизованный ввод данных</h2>\r\n      <p>Буферизованные ввод и вывод данных через консоль реализуются практически\r\n      одинаково. Вспомним, как осуществляется вывод:</p>\r\n      <pre v-highlightjs><code class=\"x86asm\">string db 'Hello, world!', 13, 10, '$'\r\n\r\nlea dx, string  ; Загрузка адреса в dx\r\nmov ah, 9  ; Установка кода операции вывода строки\r\nint 21h  ; Вызов сервиса DOS</code></pre>\r\n      <p>Как вы, надеюсь, помните (ибо конструкция действительно фундаментальная),\r\n      <span class=\"code\">mov ah, КОД</span> и <span class=\"code\">int 21h</span>\r\n      вместе осуществляют вызов некоторой системной процедуры, определяемой записанным\r\n      в AH кодом. В случае с 9, по адресу из регистра DX будет выведена строка\r\n      символов вплоть до символа-ограничителя, которым служит знак доллара ('$').\r\n      Операция же <i>ввода</i> строки соответствует коду 0Ah, который запишет\r\n      введённую в консоль строку в массив по адресу, опять-таки лежащему в DX.\r\n      При этом сам массив будет иметь несколько иную структуру:</p>\r\n      <pre v-highlightjs><code class=\"x86asm\">array db 8, ?, 8 dup(?)\r\n\r\nlea dx, array\r\nmov ah, 0Ah\r\nint 21h</code></pre>\r\n      <p>Запись формата <span class=\"code\">8 dup(?)</span> в первой лабораторной не\r\n      фигурировала, так что следует пояснить её смысл. Первое число - количество повторений.\r\n      dup - сокращение от duplicate. (?) - элемент, который надо будет повторять. Таким образом,\r\n      <span class=\"code\">array db 5 dup(0)</span> выделит 5 байт памяти и заполнит их нулями,\r\n      <span class=\"code\">array db 8 dup('A')</span> - 8 байт, каждый из которых равен коду символа\r\n      'A', а <span class=\"code\">array db 8 dup(?)</span> просто выделит память под 8 элементов\r\n      массива, но прибираться там не станет, оставив мусор лежать на метафорическом полу\r\n      нашей памяти.</p>\r\n      <p>Появляется вполне закономерный вопрос: что все эти числа значат? У людей,\r\n      уже посмотревших на само задание ко второй лабораторной, кроме этого вопроса\r\n      возникает и другой: почему там фигурируют восьмёрки, если нам нужен массив из\r\n      семи элементов?</p>\r\n      <p>Это связано с той самой подковыристой структурой массива, в который будет\r\n      записываться строка из консоли. Первый байт массива всегда содержит его \"длину\",\r\n      если быть точным - максимальное число символов, которое разрешено ввести в консоль,\r\n      включая символ-терминатор (в данном случае - перевод каретки по коду 13). Именно\r\n      поэтому для массива из 7 элементов указывается длина 8. Второй байт мы оставляем\r\n      неинициализированным, потому что его перезапишет сама вызванная процедура. В нём\r\n      будет лежать число <i>действительно</i> введённых пользователем символов, <i>исключая</i>\r\n      символ-ограничитель: введя в консоль \"Hello\", массив примет вид\r\n      <span class=\"code\">8, 5, 'h', 'e', 'l', 'l', 'o', 13, ?, ?</span>. После этого байта\r\n      выделяется память уже непосредственно под элементы массива, объём выделенной памяти,\r\n      по-хорошему, должен быть не меньше, чем число в первом байте (что очевидно).</p>\r\n    </section>\r\n    <section>\r\n      <h2>Проверка числа на чётность</h2>\r\n      <p>Вторым и, фактически, последним новым приёмом в этой лабораторной работе\r\n      является проверка числа на чётность. В примере решения первого варианта\r\n      проверка на чётность уже приведена:</p>\r\n      <pre v-highlightjs><code class=\"x86asm\">test [si], 1\r\njnz odd</code></pre>\r\n      <p>Выглядит просто. За исключением одного \"но\". test - это кто вообще, и что он тут делает?\r\n      Кто и зачем его сюда пустил? Говоря просто, test - анонимизированный AND, который\r\n      спрятался за тремя слоями VPN и прокси и, как следствие, следов за собой почти не\r\n      оставляет. Он производит побитовое \"И\" над операндами, но не изменяет ни одну из них.\r\n      Вместо этого он развешивает флаги и уходит в закат. Проведя побитовое \"И\" числа с\r\n      единицей, мы можем получить всего два различных результата: 0 и 1. Если\r\n      в результате получился ноль, число, очевидно, чётное. Если единица - нечётное.\r\n      Проверить это можно по флагу нуля ZF: <span class=\"code\">jz</span> совершит\r\n      переход при чётности числа, <span class=\"code\">jnz</span> - при нечётности.</p>\r\n      <p>Чисто технически, никто не мешает нам разделить число на 2 и, заигрывая,\r\n      стрельнуть глазками в сторону регистра AH с остатком от деления, сравнив его\r\n      с нулём. Примерно так бы мы и поступили в другом, высокоуровневом ЯП,\r\n      но в Ассемблере для этого надо своими, вот этими вот руками в отдельный\r\n      регистр упихнуть делитель, в AX упихнуть само число, провести деление,\r\n      сравнить результат через cmp... Муторно, объёмно, долго и геморно.\r\n      Зачем оно нам надо, если есть AND с единицей, который умещается в\r\n      одну строку (две, если учитывать cmp) и не требует выделять под это приключение\r\n      дополнительных регистров.</p>\r\n    </section>\r\n    <section>\r\n      <h2>Вывод двузначного числа</h2>\r\n      <p>Вернёмся к теме перевода двузначных чисел в строку. Это уже было разобрано в прошлой\r\n      статье, но реитерация лишней не будет. Если число однозначное, космически сложная\r\n      операция конверсии заключается в команде <span class=\"code\">add num, 30h</span>,\r\n      т.е. прибавлении к числу код-поинта символа нуля. Обратная конверсия, соответственно,\r\n      реализуется через вычитание того же код-поинта. Если же число двузначное, нам придётся\r\n      разделить его на десять и перевести как остаток, так и частное в символы. С трёхзначными\r\n      будет ещё веселее, но это нам ещё не грозит. Это мы обсудим в разборе третьей лабы :)</p>\r\n      <p>В целом, это нельзя назвать тяжёлой задачей. Раздражающей, нудной? Легко. Сложной?\r\n      Не-а. Алгоритмика проста. Дополнительную головную боль в уравнение вносит тот факт,\r\n      что мы заранее не знаем, сколько знаков в числе. Можно, конечно, просто вывести\r\n      ноль в разряде десятков, но разве это интересно? Разве истинные погромизды стали бы\r\n      так делать? Спойлер: ещё как стали бы. Но мы - не погромизды, мы гордые бауманцы\r\n      без инстинкта самосохранения и какой-то внутренней логики, так что мы заморочимся.\r\n      Мы сравним частное с нулём и в зависимости от этого решим, в какой символ\r\n      записывать единицы, а оставшийся заполним пробелом. В итоге получится\r\n      приблизительно такой код:</p>\r\n      <pre v-highlightjs><code class=\"x86asm\">string db ?, ' ', 13, 10, '$'\r\n    ; Положим, что число расположено в bl\r\n    xor ah, ah  ; Очищаем ah для корректного деления\r\n    mov al, bl  ; Перемещаем содержимое bl в al для деления\r\n\r\n    mov bl, 10  ; Делить на константу нельзя, заносим делитель в bl\r\n    div bl  ; Совершаем деление на bl, ax делится на 10, в ah - остаток, в al - частное\r\n\r\n    add ax, 3030h  ; Переводим оба числа в символы\r\n    cmp al, 30h  ; Сравниваем уже не с нулём, а с символом нуля\r\n    jz write_single_digit  ; если там ноль, переходим к записи однозначного числа\r\n\r\n    mov string[0], al  ; Частное (десятки) в первый символ\r\n    mov string[1], ah  ; Остаток (единицы) во второй символ\r\n    jmp print  ; Пропустить блок с записью однозначного числа\r\n\r\nwrite_single_digit:\r\n    mov string[0], ah  ; Остаток (единицы) в первый символ\r\n    ; Ну и всё собсна, в string[1] уже записан пробел, вывод будет чистенький-красивенький\r\n\r\nprint:\r\n    lea dx, string\r\n    mov ah, 9\r\n    int 21h</code></pre>\r\n    </section>\r\n    <section>\r\n      <h2>Разбор решения первого варианта</h2>\r\n      <pre v-highlightjs><code class=\"x86asm\">.MODEL small\r\n.STACK 256\r\n.DATA\r\nprompt db 'Enter numeric array', 13, 10, '$'\r\narray db 8, ?, dup(?)\r\nsumStr db 13, 10, ?, 13, 10, '$'\r\n.CODE\r\n.STARTUP\r\n    ; Вывод строки с запросом на ввод данных\r\n    lea dx, prompt\r\n    mov ah, 9h\r\n    int 21h\r\n\r\n    ; Подготовка к обработке массива\r\n    mov cx, 7\r\n    lea si, array[2]\r\n    ; В оригинале в si записали array и сразу провели 2 инкремента, что является\r\n    ; первым и основным признаком старческого маразма, не делайте так.\r\n    mov al, 0  ; В al лежит сумма элементов\r\n\r\ncycle:\r\n    test [si], 1  ; Проверка на чётность\r\n    jnz odd  ; Если значение нечётное, перейти к следующему\r\n\r\n    ; Иначе прибавить к сумме и отнять 30h, чтобы перевести из символа в число\r\n    add al, [si]\r\n    sub al, 30h\r\n\r\nodd:\r\n    inc si\r\n    loop cycle\r\n\r\n    mov sumStr[2], al  ; Записать в строку вывода\r\n    add sumStr[2], 30h  ; Перевести в символ\r\n\r\n    ; Вывести на экран\r\n    lea dx, sumStr\r\n    mov ah, 9h\r\n    int 21h</code></pre>\r\n      <p>Если вы внимательно читали материал первой статьи и введение к этой статье, этот\r\n      код будет вам более или менее понятен. В первом блоке мы просто уведомляем пользователя\r\n      о том, что было бы просто офигенно ввести что-то в консольку. Во втором производится\r\n      буферизованный ввод, описанный выше в статье - записываем в DX адрес массива,\r\n      в который запишутся данные, вызываем сервис с кодом 0Ah, сервис заглядывает в первый\r\n      элемент массива, читает оттуда восьмёрку и дожидается от пользователя ввода\r\n      вплоть до семи значимых символов + терминатор (перевод каретки, '\\r', 13).\r\n      В оригинале кода, как я отметил в комментариях, адрес в SI записывается как-то\r\n      по-китайски, не делайте так - два инкремента ни по производительности, ни по\r\n      читаемости не дотягивают до лаконичного array[2], которое ещё и заменяется\r\n      на единственную числовую константу с применённым сдвигом при сборке программы.\r\n      Вывод: не делайте так, это ущербное зрелище, пг/ам (пример плохой, автор нехороший человек).</p>\r\n      <p>Далее идёт вполне стандартная аккумуляция суммы в регистре AL, объяснять\r\n      которую не вижу смысла. Проверка на чётность проводится описанным выше способом,\r\n      через побитовый \"И\" с элемента массива с единицей и проверку флага ZF. После цикла\r\n      производится запись результата в строку вывода и, в завершение Марлезонского балета,\r\n      непосредственно сам вывод. Строка вывода начинается с символов 13 и 10, чтобы обеспечить\r\n      вывод с новой строки, после пользовательского ввода.</p>\r\n    </section>\r\n    <section>\r\n      <h2>Разбор вариантов задания</h2>\r\n      <p>Ну вот, вообще не страшно, в этот раз - действительно, а не как в прошлый. Теперь\r\n      пробежимся по вариантам, они вновь парные. Первый вариант от разобранного решения\r\n      не отличается никак, потому что он, собственно, и разобран. Второй вариант снова\r\n      отличается одним символом: так как требуется найти сумму нечётных элементов,\r\n      jnz меняется на jz. Третий и четвёртый варианты совпадают с первым и вторым\r\n      соответственно за одним исключением: нужна сумма порядковых номеров. Реализуется это\r\n      аналогично реализации этих вариантов в первой лабораторной: порядковый номер есть\r\n      длина массива+1 минус содержимое CX, просто в этот раз вместо перезаписи нам нужна\r\n      сумма, а значит mov меняется на add:</p>\r\n      <pre v-highlightjs><code class=\"x86asm\">    mov al, 0\r\ncycle:\r\n    test [si], 1\r\n    jnz odd\r\n    ;; Новый код\r\n    add al, 8  ; Прибавляем к сумме длину массива+1\r\n    sub al, cl  ; Вычитаем содержимое cl, чтобы получить порядковый номер\r\n    ;; Опять старый код\r\nodd:\r\n    inc si</code></pre>\r\n      <p>Варианты 5-10 получают пощёчину в виде дополнительно введённых двух\r\n      цифр, задающих ограничивающий диапазон. Для этого нужно ввести новый массив,\r\n      точно так же считать в него цифры через буферизованный ввод и проверять числа\r\n      на вхождение в диапазон знакомыми нам по первой лабе ja, jb:</p>\r\n      <pre v-highlightjs><code class=\"x86asm\">range db 3, ?, 3 dup(?)\r\n\r\n    lea dx, range\r\n    mov ah, 0Ah\r\n    int 21h\r\n    ...\r\n    ; Заносим диапазон в регистр AX для удобства\r\n    mov al, range[2]\r\n    mov ah, range[3]\r\n    mov bl, 0  ; Положим, сумма будет в bl\r\ncycle:\r\n    cmp [si], ah\r\n    jb next  ; Меньше нижней границы, пропускаем\r\n    cmp [si], al\r\n    ja next  ; Больше верхней границы, пропускаем\r\n    ; Входит в диапазон, работаем\r\n    add bl, [si]\r\n    sub bl, 30h\r\nnext:\r\n    inc si\r\n    loop cycle\r\n    ...</code></pre>\r\n      <p>Варианты 6-8 требуют вывести на консоль сразу несколько порядковых номеров.\r\n      Сделать это можно примитивным способом, просто перезаписывая данные в строку вывода\r\n      и вызывая процедуру вывода на экран - я не вижу смысла это как-то пояснять. То же,\r\n      на самом деле, касается вариантов 9 и 10, которые просто являются вариациями уже\r\n      разобранных и решённых задач. Вот и всё. В качестве конфетки в конце привожу\r\n      своё (хоть и несколько устаревшее, сейчас я решил бы задачу чуть-чуть иначе) решение девятого\r\n      варианта и крайне наивно рассчитываю на то, что ни у кого не хватит наглости\r\n      скопировать его символ-в-символ, вырезая комментарии и пустое пространство. Удачного\r\n      выполнения, не бойтесь обращаться с вопросами и до встречи в разборе следующей лабы.</p>\r\n      <pre v-highlightjs><code class=\"x86asm\">;; Считать с клавиатуры цифровой массив, вывести сумму\r\n;; индексов чётных элементов, которые входят в указанный\r\n;; пользователем диапазон\r\n\r\n.MODEL small\r\n.STACK 256\r\nARRAY_LENGTH equ 7\r\nARRAY_CAPACITY equ ARRAY_LENGTH + 1\r\n\r\n.DATA\r\narrayPromptStr db 'Enter numeric array (7 digits): $'\r\n\r\n; Первый элемент (8) - максимальное число символов для ввода (с учётом терминатора)\r\n; Во второй элемент (?) будет записано число реально введённых символов\r\n; Затем идут 7 неинициализированных элементов (сами элементы массива)\r\n; И восьмой элемент для символа-терминатора\r\narray db ARRAY_CAPACITY, ?, ARRAY_CAPACITY dup(?)\r\n\r\nrangePromptStr db 13, 10, 'Enter acceptable value range (2 digits): $'\r\n; Аналогично, массив из двух цифр, ограничивающих диапазон для вычисления\r\nrange db 3, ?, 3 dup(?)\r\n\r\noutputAnnotationStr db 13, 10, 'Sum of positions of even elements within range: $'\r\noutputStr db ?, ' ', 13, 10, '$'\r\n.CODE\r\n.STARTUP\r\n; Запрос на ввод данных\r\n    lea dx, arrayPromptStr\r\n    mov ah, 9h\r\n    int 21h\r\n\r\n; Буферизованный ввод\r\n    lea dx, array\r\n    mov ah, 0Ah\r\n    int 21h\r\n\r\n; Запрос на ввод ограничительного диапазона\r\n    lea dx, rangePromptStr\r\n    mov ah, 9h\r\n    int 21h\r\n\r\n; Ввод ограничительного диапазона\r\n    lea dx, range\r\n    mov ah, 0Ah\r\n    int 21h\r\n\r\n; Подготовка к циклу\r\n    mov cx, ARRAY_LENGTH\r\n    mov al, 0  ; Сумма будет хранится в al\r\n    lea si, array[2]  ; Записываем адрес первого элемента массива в si\r\n\r\n; Обход элементов массива\r\ncycle:\r\n    ; Перевод из символа в число совершать не обязательно, т.к. чётность сохраняется\r\n    test BYTE PTR[si], 1  ; Тест выполняет побитовый AND, но не изменяет операнды\r\n    jnz next  ; Если число нечётное, пропустить увеличение суммы\r\n\r\n    ; Проверка на вхождение в диапазон\r\n    ; Записываем содержимое диапазона в регистры для использования cmp\r\n    mov bh, range[2]\r\n    mov bl, range[3]\r\n    cmp [si], bh\r\n    jb next\r\n    cmp [si], bl\r\n    ja next\r\n\r\n    ; Вычисление порядкового номера и увеличение суммы\r\n    mov bx, ARRAY_CAPACITY  ; Требуется номер, а не индекс, => CAPACITY\r\n    sub bx, cx\r\n    add al, bl\r\nnext:\r\n    inc si\r\n    loop cycle\r\n\r\n; Перевод суммы в строковый вид\r\n    cmp al, 9\r\n    ja convert_double_digits\r\n    ; Для однозначного числа\r\n    add al, 30h\r\n    mov outputStr[0], al\r\n    jmp print\r\n\r\nconvert_double_digits:\r\n    ; Для двузначного числа\r\n    mov ah, 0  ; Очищаем старший байт AX для корректного деления\r\n    mov bx, 10\r\n    div bl  ; AL - частное, AH - остаток\r\n\r\n    add ax, 3030h  ; Перевод в символы\r\n    mov outputStr[0], al\r\n    mov outputStr[1], ah\r\n\r\n; Вывод результата\r\nprint:\r\n    lea dx, outputAnnotationStr\r\n    mov ah, 9h\r\n    int 21h\r\n\r\n    lea dx, outputStr\r\n    int 21h\r\n.EXIT\r\nEND</code></pre>\r\n    </section>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\nname: \"asm-lab2\"\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n\r\n</style>\r\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./asm-lab2.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./asm-lab2.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./asm-lab2.vue?vue&type=template&id=34ddaff2&scoped=true&\"\nimport script from \"./asm-lab2.vue?vue&type=script&lang=js&\"\nexport * from \"./asm-lab2.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"34ddaff2\",\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}