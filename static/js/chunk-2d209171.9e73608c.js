(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d209171"],{a826:function(n,a,t){"use strict";t.r(a);var e=function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("div",[t("router-link",{attrs:{to:"/guides/asm/"}},[t("h5",[n._v("<- Вертай в зад, обратно к гайдам")])]),t("h1",[n._v("Ассемблер. Буферизованный ввод. Проверка числа на чётность. Разбор второй лабораторной работы.")]),t("section",[t("h2",[n._v("Небольшое предисловие")]),t("p",[n._v("Если вы внимательно читали разбор "),t("router-link",{attrs:{to:"/guides/asm/lab1"}},[n._v(" первой лабораторной работы")]),n._v(", в этой статье для вас новой информации практически не будет, как, собственно, и в последующих. Первая статья выполняет роль порога вхождения в Ассемблер. Её просто нужно переступить, после неё каких-то кардинально новых концептов появляться не будет. Главное - понять основные принципы работы с Ассемблером. Если же вы ещё не прочитали ту статью (или читали невнимательно, или же пропускали куски), настоятельно рекомендую это сделать сейчас, в идеале следуя за инструкциями в реальном времени, чтобы сразу закрепить изученное.")],1),t("p",[n._v('Сегодня мы изучим ввод не одного символа, а целой строки из консоли, рассмотрим проверку чисел на чётность и повторно разберём перевод двузначных чисел в символьный вид, ибо теперь он фигурирует во всех вариантах, а я могу с уверенностью сказать, что приличная доля читающих смело игнорирует мои рекомендации. Как выразился один мой близкий друг, "Я, конечно, гордый, но повторю ещё раз".')]),t("p",[n._v("Ну что же, приступим!")])]),t("section",[t("h2",[n._v("Буферизованный ввод данных")]),t("p",[n._v("Буферизованные ввод и вывод данных через консоль реализуются практически одинаково. Вспомним, как осуществляется вывод:")]),t("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[t("code",{staticClass:"x86asm"},[n._v("string db 'Hello, world!', 13, 10, '$'\n\nlea dx, string  ; Загрузка адреса в dx\nmov ah, 9  ; Установка кода операции вывода строки\nint 21h  ; Вызов сервиса DOS")])]),n._m(0),t("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[t("code",{staticClass:"x86asm"},[n._v("array db 8, ?, 8 dup(?)\n\nlea dx, array\nmov ah, 0Ah\nint 21h")])]),n._m(1),t("p",[n._v("Появляется вполне закономерный вопрос: что все эти числа значат? У людей, уже посмотревших на само задание ко второй лабораторной, кроме этого вопроса возникает и другой: почему там фигурируют восьмёрки, если нам нужен массив из семи элементов?")]),n._m(2)]),t("section",[t("h2",[n._v("Проверка числа на чётность")]),t("p",[n._v("Вторым и, фактически, последним новым приёмом в этой лабораторной работе является проверка числа на чётность. В примере решения первого варианта проверка на чётность уже приведена:")]),t("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[t("code",{staticClass:"x86asm"},[n._v("test [si], 1\njnz odd")])]),n._m(3),t("p",[n._v("Чисто технически, никто не мешает нам разделить число на 2 и, заигрывая, стрельнуть глазками в сторону регистра AH с остатком от деления, сравнив его с нулём. Примерно так бы мы и поступили в другом, высокоуровневом ЯП, но в Ассемблере для этого надо своими, вот этими вот руками в отдельный регистр упихнуть делитель, в AX упихнуть само число, провести деление, сравнить результат через cmp... Муторно, объёмно, долго и геморно. Зачем оно нам надо, если есть AND с единицей, который умещается в одну строку (две, если учитывать cmp) и не требует выделять под это приключение дополнительных регистров.")])]),t("section",[t("h2",[n._v("Вывод двузначного числа")]),n._m(4),t("p",[n._v("В целом, это нельзя назвать тяжёлой задачей. Раздражающей, нудной? Легко. Сложной? Не-а. Алгоритмика проста. Дополнительную головную боль в уравнение вносит тот факт, что мы заранее не знаем, сколько знаков в числе. Можно, конечно, просто вывести ноль в разряде десятков, но разве это интересно? Разве истинные погромизды стали бы так делать? Спойлер: ещё как стали бы. Но мы - не погромизды, мы гордые бауманцы без инстинкта самосохранения и какой-то внутренней логики, так что мы заморочимся. Мы сравним частное с нулём и в зависимости от этого решим, в какой символ записывать единицы, а оставшийся заполним пробелом. В итоге получится приблизительно такой код:")]),t("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[t("code",{staticClass:"x86asm"},[n._v("string db ?, ' ', 13, 10, '$'\n    ; Положим, что число расположено в bl\n    xor ah, ah  ; Очищаем ah для корректного деления\n    mov al, bl  ; Перемещаем содержимое bl в al для деления\n\n    mov bl, 10  ; Делить на константу нельзя, заносим делитель в bl\n    div bl  ; Совершаем деление на bl, ax делится на 10, в ah - остаток, в al - частное\n\n    add ax, 3030h  ; Переводим оба числа в символы\n    cmp al, 30h  ; Сравниваем уже не с нулём, а с символом нуля\n    jz write_single_digit  ; если там ноль, переходим к записи однозначного числа\n\n    mov string[0], al  ; Частное (десятки) в первый символ\n    mov string[1], ah  ; Остаток (единицы) во второй символ\n    jmp print  ; Пропустить блок с записью однозначного числа\n\nwrite_single_digit:\n    mov string[0], ah  ; Остаток (единицы) в первый символ\n    ; Ну и всё собсна, в string[1] уже записан пробел, вывод будет чистенький-красивенький\n\nprint:\n    lea dx, string\n    mov ah, 9\n    int 21h")])])]),t("section",[t("h2",[n._v("Разбор решения первого варианта")]),t("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[t("code",{staticClass:"x86asm"},[n._v(".MODEL small\n.STACK 256\n.DATA\nprompt db 'Enter numeric array', 13, 10, '$'\narray db 8, ?, dup(?)\nsumStr db 13, 10, ?, 13, 10, '$'\n.CODE\n.STARTUP\n    ; Вывод строки с запросом на ввод данных\n    lea dx, prompt\n    mov ah, 9h\n    int 21h\n\n    ; Подготовка к обработке массива\n    mov cx, 7\n    lea si, array[2]\n    ; В оригинале в si записали array и сразу провели 2 инкремента, что является\n    ; первым и основным признаком старческого маразма, не делайте так.\n    mov al, 0  ; В al лежит сумма элементов\n\ncycle:\n    test [si], 1  ; Проверка на чётность\n    jnz odd  ; Если значение нечётное, перейти к следующему\n\n    ; Иначе прибавить к сумме и отнять 30h, чтобы перевести из символа в число\n    add al, [si]\n    sub al, 30h\n\nodd:\n    inc si\n    loop cycle\n\n    mov sumStr[2], al  ; Записать в строку вывода\n    add sumStr[2], 30h  ; Перевести в символ\n\n    ; Вывести на экран\n    lea dx, sumStr\n    mov ah, 9h\n    int 21h")])]),t("p",[n._v("Если вы внимательно читали материал первой статьи и введение к этой статье, этот код будет вам более или менее понятен. В первом блоке мы просто уведомляем пользователя о том, что было бы просто офигенно ввести что-то в консольку. Во втором производится буферизованный ввод, описанный выше в статье - записываем в DX адрес массива, в который запишутся данные, вызываем сервис с кодом 0Ah, сервис заглядывает в первый элемент массива, читает оттуда восьмёрку и дожидается от пользователя ввода вплоть до семи значимых символов + терминатор (перевод каретки, '\\r', 13). В оригинале кода, как я отметил в комментариях, адрес в SI записывается как-то по-китайски, не делайте так - два инкремента ни по производительности, ни по читаемости не дотягивают до лаконичного array[2], которое ещё и заменяется на единственную числовую константу с применённым сдвигом при сборке программы. Вывод: не делайте так, это ущербное зрелище, пг/ам (пример плохой, автор нехороший человек).")]),t("p",[n._v('Далее идёт вполне стандартная аккумуляция суммы в регистре AL, объяснять которую не вижу смысла. Проверка на чётность проводится описанным выше способом, через побитовый "И" с элемента массива с единицей и проверку флага ZF. После цикла производится запись результата в строку вывода и, в завершение Марлезонского балета, непосредственно сам вывод. Строка вывода начинается с символов 13 и 10, чтобы обеспечить вывод с новой строки, после пользовательского ввода.')])]),t("section",[t("h2",[n._v("Разбор вариантов задания")]),t("p",[n._v("Ну вот, вообще не страшно, в этот раз - действительно, а не как в прошлый. Теперь пробежимся по вариантам, они вновь парные. Первый вариант от разобранного решения не отличается никак, потому что он, собственно, и разобран. Второй вариант снова отличается одним символом: так как требуется найти сумму нечётных элементов, jnz меняется на jz. Третий и четвёртый варианты совпадают с первым и вторым соответственно за одним исключением: нужна сумма порядковых номеров. Реализуется это аналогично реализации этих вариантов в первой лабораторной: порядковый номер есть длина массива+1 минус содержимое CX, просто в этот раз вместо перезаписи нам нужна сумма, а значит mov меняется на add:")]),t("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[t("code",{staticClass:"x86asm"},[n._v("    mov al, 0\ncycle:\n    test [si], 1\n    jnz odd\n    ;; Новый код\n    add al, 8  ; Прибавляем к сумме длину массива+1\n    sub al, cl  ; Вычитаем содержимое cl, чтобы получить порядковый номер\n    ;; Опять старый код\nodd:\n    inc si")])]),t("p",[n._v("Варианты 5-10 получают пощёчину в виде дополнительно введённых двух цифр, задающих ограничивающий диапазон. Для этого нужно ввести новый массив, точно так же считать в него цифры через буферизованный ввод и проверять числа на вхождение в диапазон знакомыми нам по первой лабе ja, jb:")]),t("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[t("code",{staticClass:"x86asm"},[n._v("range db 3, ?, 3 dup(?)\n\n    lea dx, range[2]\n    mov ah, 0Ah\n    int 21h\n    ...\n    ; Заносим диапазон в регистр AX для удобства\n    mov al, range[0]\n    mov ah, range[1]\n    mov bl, 0  ; Положим, сумма будет в bl\ncycle:\n    cmp [si], ah\n    jb next  ; Меньше нижней границы, пропускаем\n    cmp [si], al\n    ja next  ; Больше верхней границы, пропускаем\n    ; Входит в диапазон, работаем\n    add bl, [si]\n    sub bl, 30h\nnext:\n    inc si\n    loop cycle\n    ...")])]),t("p",[n._v("Варианты 6-8 требуют вывести на консоль сразу несколько порядковых номеров. Сделать это можно примитивным способом, просто перезаписывая данные в строку вывода и вызывая процедуру вывода на экран - я не вижу смысла это как-то пояснять. То же, на самом деле, касается вариантов 9 и 10, которые просто являются вариациями уже разобранных и решённых задач. Вот и всё. В качестве конфетки в конце привожу своё (хоть и несколько устаревшее, сейчас я решил бы задачу чуть-чуть иначе) решение девятого варианта и крайне наивно рассчитываю на то, что ни у кого не хватит наглости скопировать его символ-в-символ, вырезая комментарии и пустое пространство. Удачного выполнения, не бойтесь обращаться с вопросами и до встречи в разборе следующей лабы.")]),t("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[t("code",{staticClass:"x86asm"},[n._v(";; Считать с клавиатуры цифровой массив, вывести сумму\n;; индексов чётных элементов, которые входят в указанный\n;; пользователем диапазон\n\n.MODEL small\n.STACK 256\nARRAY_LENGTH equ 7\nARRAY_CAPACITY equ ARRAY_LENGTH + 1\n\n.DATA\narrayPromptStr db 'Enter numeric array (7 digits): $'\n\n; Первый элемент (8) - максимальное число символов для ввода (с учётом терминатора)\n; Во второй элемент (?) будет записано число реально введённых символов\n; Затем идут 7 неинициализированных элементов (сами элементы массива)\n; И восьмой элемент для символа-терминатора\narray db ARRAY_CAPACITY, ?, ARRAY_CAPACITY dup(?)\n\nrangePromptStr db 13, 10, 'Enter acceptable value range (2 digits): $'\n; Аналогично, массив из двух цифр, ограничивающих диапазон для вычисления\nrange db 3, ?, 3 dup(?)\n\noutputAnnotationStr db 13, 10, 'Sum of positions of even elements within range: $'\noutputStr db ?, ' ', 13, 10, '$'\n.CODE\n.STARTUP\n; Запрос на ввод данных\n    lea dx, arrayPromptStr\n    mov ah, 9h\n    int 21h\n\n; Буферизованный ввод\n    lea dx, array\n    mov ah, 0Ah\n    int 21h\n\n; Запрос на ввод ограничительного диапазона\n    lea dx, rangePromptStr\n    mov ah, 9h\n    int 21h\n\n; Ввод ограничительного диапазона\n    lea dx, range\n    mov ah, 0Ah\n    int 21h\n\n; Подготовка к циклу\n    mov cx, ARRAY_LENGTH\n    mov al, 0  ; Сумма будет хранится в al\n    lea si, array[2]  ; Записываем адрес первого элемента массива в si\n\n; Обход элементов массива\ncycle:\n    ; Перевод из символа в число совершать не обязательно, т.к. чётность сохраняется\n    test BYTE PTR[si], 1  ; Тест выполняет побитовый AND, но не изменяет операнды\n    jnz next  ; Если число нечётное, пропустить увеличение суммы\n\n    ; Проверка на вхождение в диапазон\n    ; Записываем содержимое диапазона в регистры для использования cmp\n    mov bh, range[2]\n    mov bl, range[3]\n    cmp [si], bh\n    jb next\n    cmp [si], bl\n    ja next\n\n    ; Вычисление порядкового номера и увеличение суммы\n    mov bx, ARRAY_CAPACITY  ; Требуется номер, а не индекс, => CAPACITY\n    sub bx, cx\n    add al, bl\nnext:\n    inc si\n    loop cycle\n\n; Перевод суммы в строковый вид\n    cmp al, 9\n    ja convert_double_digits\n    ; Для однозначного числа\n    add al, 30h\n    mov outputStr[0], al\n    jmp print\n\nconvert_double_digits:\n    ; Для двузначного числа\n    mov ah, 0  ; Очищаем старший байт AX для корректного деления\n    mov bx, 10\n    div bl  ; AL - частное, AH - остаток\n\n    add ax, 3030h  ; Перевод в символы\n    mov outputStr[0], al\n    mov outputStr[1], ah\n\n; Вывод результата\nprint:\n    lea dx, outputAnnotationStr\n    mov ah, 9h\n    int 21h\n\n    lea dx, outputStr\n    int 21h\n.EXIT\nEND")])])])],1)},s=[function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("p",[n._v("Как вы, надеюсь, помните (ибо конструкция действительно фундаментальная), "),t("span",{staticClass:"code"},[n._v("mov ah, КОД")]),n._v(" и "),t("span",{staticClass:"code"},[n._v("int 21h")]),n._v(" вместе осуществляют вызов некоторой системной процедуры, определяемой записанным в AH кодом. В случае с 9, по адресу из регистра DX будет выведена строка символов вплоть до символа-ограничителя, которым служит знак доллара ('$'). Операция же "),t("i",[n._v("ввода")]),n._v(" строки соответствует коду 0Ah, который запишет введённую в консоль строку в массив по адресу, опять-таки лежащему в DX. При этом сам массив будет иметь несколько иную структуру:")])},function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("p",[n._v("Запись формата "),t("span",{staticClass:"code"},[n._v("8 dup(?)")]),n._v(" в первой лабораторной не фигурировала, так что следует пояснить её смысл. Первое число - количество повторений. dup - сокращение от duplicate. (?) - элемент, который надо будет повторять. Таким образом, "),t("span",{staticClass:"code"},[n._v("array db 5 dup(0)")]),n._v(" выделит 5 байт памяти и заполнит их нулями, "),t("span",{staticClass:"code"},[n._v("array db 8 dup('A')")]),n._v(" - 8 байт, каждый из которых равен коду символа 'A', а "),t("span",{staticClass:"code"},[n._v("array db 8 dup(?)")]),n._v(" просто выделит память под 8 элементов массива, но прибираться там не станет, оставив мусор лежать на метафорическом полу нашей памяти.")])},function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("p",[n._v('Это связано с той самой подковыристой структурой массива, в который будет записываться строка из консоли. Первый байт массива всегда содержит его "длину", если быть точным - максимальное число символов, которое разрешено ввести в консоль, включая символ-терминатор (в данном случае - перевод каретки по коду 13). Именно поэтому для массива из 7 элементов указывается длина 8. Второй байт мы оставляем неинициализированным, потому что его перезапишет сама вызванная процедура. В нём будет лежать число '),t("i",[n._v("действительно")]),n._v(" введённых пользователем символов, "),t("i",[n._v("исключая")]),n._v(' символ-ограничитель: введя в консоль "Hello", массив примет вид '),t("span",{staticClass:"code"},[n._v("8, 5, 'h', 'e', 'l', 'l', 'o', 13, ?, ?")]),n._v(". После этого байта выделяется память уже непосредственно под элементы массива, объём выделенной памяти, по-хорошему, должен быть не меньше, чем число в первом байте (что очевидно).")])},function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("p",[n._v('Выглядит просто. За исключением одного "но". test - это кто вообще, и что он тут делает? Кто и зачем его сюда пустил? Говоря просто, test - анонимизированный AND, который спрятался за тремя слоями VPN и прокси и, как следствие, следов за собой почти не оставляет. Он производит побитовое "И" над операндами, но не изменяет ни одну из них. Вместо этого он развешивает флаги и уходит в закат. Проведя побитовое "И" числа с единицей, мы можем получить всего два различных результата: 0 и 1. Если в результате получился ноль, число, очевидно, чётное. Если единица - нечётное. Проверить это можно по флагу нуля ZF: '),t("span",{staticClass:"code"},[n._v("jz")]),n._v(" совершит переход при чётности числа, "),t("span",{staticClass:"code"},[n._v("jnz")]),n._v(" - при нечётности.")])},function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("p",[n._v("Вернёмся к теме перевода двузначных чисел в строку. Это уже было разобрано в прошлой статье, но реитерация лишней не будет. Если число однозначное, космически сложная операция конверсии заключается в команде "),t("span",{staticClass:"code"},[n._v("add num, 30h")]),n._v(", т.е. прибавлении к числу код-поинта символа нуля. Обратная конверсия, соответственно, реализуется через вычитание того же код-поинта. Если же число двузначное, нам придётся разделить его на десять и перевести как остаток, так и частное в символы. С трёхзначными будет ещё веселее, но это нам ещё не грозит. Это мы обсудим в разборе третьей лабы :)")])}],i={name:"asm-lab2"},r=i,l=t("2877"),v=Object(l["a"])(r,e,s,!1,null,"19193d86",null);a["default"]=v.exports}}]);
//# sourceMappingURL=chunk-2d209171.9e73608c.js.map